---
layout:     post
title:      NestJs入门
subtitle:   构建高效、可扩展的 Node.js 服务器端应用的框架。采用模块化架构允许使用任何其他库，为您提供真正的灵活性。
date:       2023-12-6
author:     page
header-img: img/NextJs.png
catalog: true
tags:
    - NodeJs
---

# NestJs

## 开始

### 创建项目

**Nest命令行创建**

```shell
npm i -g @nestjs/cli
nest new project-name
```

**手动创建**

```shell
npm i --save @nestjs/core @nestjs/common rxjs reflect-metadata
```

### 核心文件

`app.module.t` 应用的根模块

`app.controller.ts` 具有单一路由的基本控制器

`app.service.ts` 具有单一方法的基本服务

`app.controller.spec.ts` 控制器的单元测试文件

`main.ts` 使用核心函数 `NestFactory` 创建 Nest 应用实例的应用入口文件

### 启动

```shell
npm run start:dev
```

## Controller

### 路由

控制器负责处理传入的 **requests** 并将 **responses** 返回给客户端，采用 **routing** 机制控制哪个控制器接收哪些请求

```ts
import { Controller, Get, Post } from '@nestjs/common';
import { AppService } from './app.service';
// 路由路径前缀，对路由分组
@Controller('article')
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('one') // 请求方法装饰器为 HTTP 请求的特定端点创建处理程序
  // /article/one
  getArticle(): string {
    return this.appService.getArticle();
  }

  @Post()
  editArticle(): string {
    return this.appService.editArticle();
  }
}
```

**请求方法**

所有标准的HTTP 方法装饰器：`@Get()`、`@Post()`、`@Put()`、`@Delete()`、`@Patch()`、`@Options()` 和 `@Head()`；

此外定义了一个 `@All()` 来处理所有HTTP 方法

**路由通配符**

路由路径支持正则的通配符匹配，如 `@Get('article*')`

**子域路由**

除了匹配路径的路由，支持host选项指定匹配主机的路由

```ts
@Controller({ host: 'xxx.example.com' })
export class AppController() {
  @Get()
  getData(): string {  // 支持 @HostParam() 获取动态主机参数
    // 子域路由处理
  }
}
```

### 操作响应

默认nest根据请求处理返回数据的类型选择是否自动序列化，且 **状态码** 默认情况下始终为 200，可通过 `@HttpCode()` 装饰器自定义 ;

对于动态状态码，可通过使用库的响应对象上原生响应处理方法，以 `express` 为例：

```ts
@Get()
getArticle(@Res() response): void {
  const data = this.appService.getArticle();
  response.status(400).send(data)
}
```

### 请求对象

通过 `@Req()` 装饰器访问客户端 **request** 的详细信息

```ts
import { Controller, Get, Post, Req, Res } from '@nestjs/common';
import { AppService } from './app.service';
import { Request } from 'express';

@Controller('article')
export class AppController {
  constructor(private readonly appService: AppService) {}
  @Get('one')
  getArticle(@Req() request: Request, @Res() response): void {
    const data = this.appService.getArticle();
    console.log(request)
    response.status(400).send(data)
  }
}
```

### 状态码

如前面所述，默认响应状态码 200（post为201），可通过装饰器 `@HttpCode(code)` 修改行为

```ts
@Post('list')
@HttpCode(200)
getList(){
  ...
}
```

### 响应头

使用装饰器 `@Header()` 或库的响应对象 `res.header()` 自定义响应头

```ts
@Post('login')
@Header('Cookie', 'xxxx')
login(){
  ...
}
```

### 重定向

使用装饰器 `@Redirect` 或库的响应对象 `res.redirect()` 响应重定向

```ts
@Post('login')
@Redirect('https://nest.nodejs.cn', 301)
```

### 路由参数

通过带参数的路由（动态路径）传参时，通过 `@Param` 装饰器访问

```ts
@Get('info/:id')
getInfo(@Param('id') id: string): string {
  return `info: id is ${id}`
}
```

### 异步处理

采用异步处理让Nest解析延迟值

```ts
@Get()
async fingAll(): Promise<any[]> {
  return [];
}
```

### 请求负载

通过 `@Body()` 装饰器接收POST路由参数，在此之前需要先使用class类或Ts接口声明DTO

```ts
// 推荐使用class类
const class CreateDTO {
  name: string;
  age: number;
}
```

```ts
@Post('create)
async create(@Body() createDTO: CreateDTO): string {
  ......
}
```

### 特定库的响应对象

允许通过库的响应对象暴露API进行完全控制

```ts
import { Post, Res, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Post()
create(@Res() res: Response) {
  res.status(HttpStatus.CREATED).json([]);
}
```

这会失去Nest标准响应功能，可以设置响应头 `passthrough` 实现兼容

```ts
@Get()
findAll(@Res({ passthrough: true }) res: Response) {
  res.status(HttpStatus.OK);
  ......
  return [];
}
```

### 使用控制器类

声明的 `Controller`  类在  `@Module()` 装饰器的 `controllers` 将元数据附加到模块类

```ts
// 根模块类 app.module.ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController], // 模块所需控制器
})
export class AppModule {}
```

## Provider

NestJs中专于向其它对象提供功能并通过 `injected` 建立依赖关系的类，按功能可划分为服务、存储库、工厂、助手

### 基本使用

**定义提供者 `@Injectable`**

```ts
// article.service.ts
import { Injectable } from '@nestjs/common';
import { Article } from "./interfaces/article.interface"

@Injectable()
export class ArticleService {
  private readonly articles: Array<Article> = [];

  createArticle(article: Article): Article {
    this.articles.push(article)
    return article;
  }

  getArticles(): Array<Article> {
    return this.articles;
  }
}
```

通过CLI命令 `nest g service article` 快速创建服务

**定义类型**

```ts
export interface Article {
  name: string,
  author: string,
  pageTotal: number
}
```

**定义DTO**

```ts
export class CreateArticleDTO {
  name: string;
  author: string;
  pageTotal: number
}
```

**Controll中使用**

```ts
// article.controller.ts
import { Controller, Get, Post, Body } from '@nestjs/common';
import { CreateArticleDTO } from "./dto/create-article.dto";
import {Article} from "./interfaces/article.interface"
import { ArticleService } from './article.service';

@Controller('article')
export class ArticleController {
  // 类私有的实例属性
  constructor(private readonly articleService: ArticleService) {

  }

  @Get('all')
  async getArticles(): Promise<Array<Article>> {
    return await this.articleService.getArticles();
  }

  @Post('create')
  async createArticle(@Body() createArticleDTO: CreateArticleDTO): Promise<Article> {
    return await this.articleService.createArticle(createArticleDTO)
  }
}
```

### 依赖注入

Injectable 声明服务由IoC（控制反转）管理的类，通过依赖注入的设计模式很好地管理依赖；

具体实现：实现特定参数的构造函数，在新建对象时传入所依赖类型的对象

```ts
constructor(private catsService: CatsService) {}  // 按类型解析
```

### 属性注入

当你的类多层拓展时

```typescript
import { Injectable, Inject } from '@nestjs/common';

@Injectable()
export class HttpService<T> {
  @Inject('HTTP_OPTIONS')
  private readonly httpClient: T;
}
```

### 注册提供者

```ts
import { Module } from '@nestjs/common';
import { ArticleController } from './article/article.controller';
import { ArticleService } from './article/article.service';

// 应用根模块
@Module({
  imports: [],
  controllers: [ArticleController],
  providers: [ArticleService], // 注册提供者
})
export class AppModule {}
```

### 模块

抽象功能模块，通过 `@Module` 供 **Nest** 用来组织应用结构的元数据（单个对象形式）

**属性**

**providers：** 可injectable实例化并支持模块内共享的程序

**controllers：** 需实例化的控制器集合

**imports：** Module所需的可提供程序模块列表

**exports：** Module被导入时提供的可用程序，如本身或者provide值

## Module

### 基础使用

**创建模块**

```ts
// article/article.controller.ts
import { Module } from '@nestjs/common';
import { ArticleController } from './article.controller';
import { ArticleService } from './article.service';

@Module({
  controllers: [ArticleController],
  providers: [ArticleService],
})
export class ArticleModule {}
```

通过CLI命令 `nest g module article` 快速创建 module

**导入模块**

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { ArticleModule } from './article/article.module';

// 应用根模块
@Module({
  imports: [ArticleModule],
})
export class AppModule {}
```

### 共享模块

任何导入了ArticleModule的模块将共享同一个实例

```ts
import {Module} from '@nestjs/common';
import {ArticleController} from './article.controller';
import {ArticleService} from './article.service';

@Module({
  controllers: [ ArticleController ],
  providers: [ArticleService],
  exports: [ArticleService]   // 导出
})
export class ArticleModule {}
```

### 模块导出

```ts
@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}


```

### 依赖注入

```ts
@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {
  constructor(private catsService: CatsService) {}
}
```

### 全局模块

使用 `@Global()` 实现无需导入 `imports` 的全局可用模块，如助手、数据库连接

```ts
@Global()
@Module({
  controllers: [ArticleController],
  providers: [ArticleService],
  exports: [ArticleService],
})
export class ArticleModule {}
```

## Middleware

默认情况下，Nest 中间件等同于 express

Nest中使用中间件通过函数或 `@Injectable()` 装饰器的类实现

### 定义中间件

```ts
import { Injectable, NestMiddleware } from "@nestjs/common";
import { Request, Response, NextFunction } from "express";

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log('a request coming');
    next();
  }
}
```

### 应用中间件

```ts
import { MiddlewareConsumer,NestModule, Module } from '@nestjs/common';
import { ArticleModule } from './article/article.module';
import { LoggerMiddleware } from "./middleware/logger.middleware";

@Module({
  imports: [ArticleModule],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer){
    consumer
      .apply(LoggerMiddleware) // 支持依次传入多个中间件
      .forRoutes('*') // 服务于路由，此处使用通配符匹配所有路径
  }
}
```

限制到特定请求方法

```ts
import { RequestMethod, MiddlewareConsumer } from '@nestjs/common';

configure(consumer: MiddlewareConsumer) {
  consumer
    .apply(LoggerMiddleware)
    .forRoutes({ path: 'cats', method: RequestMethod.GET });
}
```

### 依赖注入

```ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerService {
  log(message: string) {
    console.log(message);
  }
}

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  constructor(private readonly loggerService: LoggerService) {}

  use(req: Request, res: Response, next: NextFunction) {
    this.loggerService.log('Middleware logging...');
    next();
  }
}
```

### MiddlewareConsumer

中间件消费者，提供内置方法并以链式调用（chained）的管理中间件辅助类

**forRoutes**

若干字符串、一个 `RouteInfo` 对象、若干控制器类，`forRoutes(ArticleController)`

**exclude**

排除某些路由不应用中间件

### 功能中间件

函数方式中间件的实现

```ts
import { Request, Response, NextFunction } from 'express';

export function logger(req: Request, res: Response, next: NextFunction) {
  console.log(`Request...`);
  next();
};
```

### 全局中间件

```ts
const app = await NestFactory.create(AppModule);
app.use(logger);
await app.listen(3000);
```

或者 AppModule 下

```ts
consumer
      .apply(logger)
      .forRoutes('*') // 全局路由
```
