---
layout:     post
title:      React
subtitle:   用于构建 Web 和原生交互界面的库
date:       2023-5-16
author:     page
header-img: img/react.jpg
catalog: true
tags:
    - React
---

# React

中文文档：[https://react.docschina.org/](https://react.docschina.org/) 官方文档：[https://react.dev/](https://react.dev/)

## 安装

```shell
npm install react react-dom
```

`react`：包含 React 的核心功能，包括创建组件、管理组件的生命周期和处理状态等。它是你编写 React 组件所需的基础库。

`react-dom`：提供了将 React 组件渲染到 DOM（Document Object Model）中的特定方法。

## 基础

### UI

**porps**

```jsx
export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}
```

**条件渲染**

使用 JavaScript 的 `if` 语句、`&&` 和 `? :` 运算符来选择性地渲染 JSX；

**渲染列表**

`filter()` 筛选需要渲染的组件和使用 `map()` 把数组转换成组件数组。

### 添加交互

**事件**

```jsx
<button onClick={handleClick}>Button</button>
```

**state**

`setMessage(e.target.value)`

`setState((index) => index + 100)`

**更新对象**

```jsx
setPosition({ x: e.clientX, y: e.clientY });
const nextArtists = [...artists.slice(0, insertAt)];
setArtists(nextArtists);
```

```jsx
import { useImmer } from 'use-immer';
const [person, updatePerson] = useImmer({})
updatePerson(draft => {
  draft.artwork.city = e.target.value;
});
updateMyList(draft => {
  const artwork = draft.find(a => a.id === id);
  artwork.seen = nextSeen;
});
```

### 状态管理

**state的保留与重置**

相同位置的相同组件会使得 state 被保留下来（可使用key以及多个组件实现重置）

相同位置的不同组件会使 state 重置

**Reducer**

```js
function tasksReducer(tasks, action) {
  if (action.type === 'added') {
    ......
    return [];
  }
}
```

```js
import { useReducer } from 'react';
import { useImmerReducer } from 'use-immer';
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
const [tasks, dispatch] = useImmerReducer(tasksReducer, initialTasks);
```

**Context**

创建 context

```jsx
import { createContext } from 'react';

export const LevelContext = createContext(1);
```

使用 context

```jsx
import { LevelContext } from './LevelContext.js';
export default function Heading({ children }) {
  const level = useContext(LevelContext); // 访问上层最近
  // ...
}
```

提供 context

```jsx
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';

export default function Section({ children }) {
  const level = useContext(LevelContext); // 访问上层最近
  return (
    <section className="section">
      <LevelContext.Provider value={level + 1}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```

**reducer + context**

创建 context

```jsx
import { createContext } from 'react';

export const TasksContext = createContext(null);
export const TasksDispatchContext = createContext(null);
```

state 和 dispatch 函数 放入 context

```jsx
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
  // ...
  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>
        ...
      </TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}
```

接收使用

```jsx
export default function TaskList() {
  const tasks = useContext(TasksContext);
  // ...
```

```jsx
export default function AddTask() {
  const [text, setText] = useState('');
  const dispatch = useContext(TasksDispatchContext);
  // ...
  return (
    // ...
    <button onClick={() => {
      setText('');
      dispatch({
        type: 'added',
        id: nextId++,
        text: text,
      });
    }}>Add</button>
    // ...
```

迁移逻辑

```jsx
import { createContext, useContext, useReducer } from 'react';

const TasksContext = createContext(null);

const TasksDispatchContext = createContext(null);

export function TasksProvider({ children }) {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>
        {children}
      </TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}

export function useTasks() {
  return useContext(TasksContext);
}

export function useTasksDispatch() {
  return useContext(TasksDispatchContext);
}
```

## 框架构建

**Next.js**：`npx create-next-app@latest`

**create-react-app**：`npx create-react-app my-app`

**vite**：

组件化：

页面拆分独立的、可复用的部分开发，每个部分都有自己的职责和功能

模块化：

业务功能拆分，拆分模块提供功能，供其它模块使用

react

将原生dom看做组件，通过组合dom，人为自定义组件

状态、虚拟dom、组合优于继承、单项数据流
