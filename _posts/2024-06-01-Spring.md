---
layout:     post
title:      Spring框架
subtitle:   一个支持快速开发Java EE应用程序的框架。提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成
date:       2024-06-01
author:     page
header-img: img/Spring.webp
catalog: true
tags:
    - Java
---

# Spring框架

[Spring官网](https://spring.io/projects/spring-framework)

### Spring Framework

[Spring Framework官方文档](https://spring.io/projects/spring-framework)

Spring Framework主要包括几个模块：

- 支持IoC和AOP的容器；
- 支持JDBC和ORM的数据访问模块；
- 支持声明式事务的模块；
- 支持基于Servlet的MVC开发；
- 支持基于Reactive的Web开发；
- 以及集成JMS、JavaMail、JMX、缓存等其他模块。 

## IoC容器

容器，一种为某种特定组件的运行提供必要支持的一个软件环境

Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境

Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程

Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

### IoC原理

如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

因此，核心问题是：

1. 谁负责创建组件？
2. 谁负责根据依赖关系组装组件？
3. 销毁时，如何按依赖顺序正确销毁？

解决这一问题的核心方案就是IoC。

传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制；

在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，

```java
public class BookService {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。

**配置Ioc容器**

IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系，可通过 xml 配置实现

```xml
<beans>
    <bean id="dataSource" class="HikariDataSource" />
    <bean id="bookService" class="BookService">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean id="userService" class="UserService">
        <property name="dataSource" ref="dataSource" />
    </bean>
</beans>
```

IoC容器创建3个JavaBean组件，并把id为`dataSource`的组件通过属性`dataSource`（即调用`setDataSource()`方法）注入到另外两个组件中。

在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean

**依赖注入方式（构造方法）**

```java
public class BookService {
    private DataSource dataSource;

    public BookService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

### 装配Bean

Maven创建工程并引入`spring-context`依赖：

- org.springframework:spring-context:6.0.0

以编写简单 `UserService` 为例

```java
public class UserService {
    private MailService mailService;

    public void setMailService(MailService mailService) {
        this.mailService = mailService;
    }
    ...
}
```

**application.xml**

resources下特定配置文件，Spring的IoC容器应该如何创建并组装Bean：

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="userService" class="com.itranswarp.learnjava.service.UserService">
        <property name="mailService" ref="mailService" />
    </bean>
    <bean id="mailService" class="com.itranswarp.learnjava.service.MailService" />
</beans>
```

- 每个`<bean ...>`都有一个`id`标识，相当于Bean的唯一ID；
- 在`userService`Bean中，通过`<property name="..." ref="..." />`注入了另一个Bean；
- Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。

如果注入的不是Bean，而是`boolean`、`int`、`String`这样的数据类型，则通过`value`注入，例如，创建一个`HikariDataSource`：

```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource">
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="autoCommit" value="true" />
</bean>
```

**创建IoC容器**

`main()` 方法创建一个Spring的IoC容器实例，然后加载配置文件

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        UserService userService = context.getBean(UserService.class);
        User user = userService.login("bob@example.com", "password");
        System.out.println(user.getName());
    }
}
```

从`ApplicationContext`中我们可以根据Bean的类型获取Bean的引用：

```java
UserService userService = context.getBean(UserService.class);
```

### Annotation配置

通过 @component 注解方式，不需要XML，让Spring自动扫描Bean并组装它们

```java
// MailService
package com.itranswarp.learnjava.service;
import org.springframework.stereotype.Component;

@Component
public class MailService {
    ...
}

// UserService
package com.itranswarp.learnjava.service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class UserService {
 @Autowired
 MailService mailService;
 ...
 // 或 set 方法、构造方法中
 public UserService(@Autowired MailService mailService) {
        this.mailService = mailService;
    }
}
```

编写 `AppConfig` 类（AppConfig.java）启动容器

```js
import com.itranswarp.learnjava.service.User;
import com.itranswarp.learnjava.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.itranswarp.learnjava.service")
public class AppConfig {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService userService = context.getBean(UserService.class);
        User user = userService.login("bob@example.com", "password");
        System.out.println(user.getName());

    }
}
```

`@Configuration` 标注表示它是一个配置类，因为我们创建 `ApplicationContext` 时，使用的实现类是 `AnnotationConfigApplicationContext`，必须传入一个标注了`@Configuration` 的类名

`@ComponentScan` 标注容器，自动搜索当前类所在的包以及子包，把所有标注为`@Component` 的Bean自动创建出来，并根据 `@Autowired` 进行装配

通常，启动配置 `AppConfig` 位于自定义的顶层包，其他Bean按类别放入子包

### 定制Bean
