---
layout:     post
title:      tiptap
subtitle:   ä¸€å¥—å¼€æºå†…å®¹ç¼–è¾‘å’Œå®æ—¶åä½œå·¥å…·ï¼ŒåŸºäºProseMirror
date:       2023-11-27
author:     page
header-img: img/tiptap.png
catalog: true
tags:
    - ç±»åº“
---

# Tiptap

[å®˜æ–¹æ–‡æ¡£](https://tiptap.dev/) [ä¸­æ–‡æ–‡æ¡£](https://www.itxst.com/tiptap/tutorial.html)

## å®‰è£…

```shell
npm i @tiptap/core @tiptap/starter-kit -S
```

## åˆå§‹åŒ–

```js
import { Editor } from "@tiptap/core";
import StarterKit from "@tiptap/starter-kit"; // å…¥é—¨å¥—ä»¶å³å¸¸ç”¨æ‹“å±•é›†åˆ

const editor = new Editor({
  element: document.querySelector(".editor"),
  extensions: [
    StarterKit,
    Underline,
    TextStyle,
    Color,
    FontSize,
    Highlight.configure({ multicolor: true }),
    Image.configure({
      inline: true,
    }),
    ...
  ],
});
```

### Vue

**å®‰è£…**ï¼š`npm install @tiptap/vue-3 @tiptap/pm @tiptap/starter-kit`

**ä½¿ç”¨**

```html
<template>
  <editor-content :editor="editor" />
</template>

<script setup>
import { useEditor, EditorContent } from '@tiptap/vue-3'
import StarterKit from '@tiptap/starter-kit'

const editor = useEditor({
  content: '<p>Iâ€™m running Tiptap with Vue.js. ğŸ‰</p>',
  extensions: [
    StarterKit,
  ],
  onUpdate: () => {
    // emit('update:modelValue', this.editor.getHTML())
  }
}

beforeUnmount(() => editor.value.destory());
</script>
```

Vue/Reactæ›´å¤šç»†èŠ‚è§å®˜æ–¹æ–‡æ¡£

## æ ¸å¿ƒ

### extension

tiptapé€šè¿‡æ‹“å±•æ‰©å……åŠŸèƒ½ï¼ŒextensionåŒ…å«ä¸€èˆ¬ç±»å‹æ‹“å±•ã€è¿˜æœ‰Nodeç±»å‹æ‹“å±•å’ŒMarkç±»å‹æ‹“å±•

#### Extensionæ‹“å±•

```js
export const Ext = Extension.create({
  name: 'æ‹“å±•åç§°',
  // å¦‚ä½•æ¸²æŸ“ä¸ºHTML
  renderHTML({ HTMLAttributes }) {
    return ['div', HTMLAttributes, 0]
  },
  // å­˜å‚¨å±æ€§ä¿¡æ¯ï¼Œä¾›è§£æä¸æ¸²æŸ“æ—¶è®¾ç½®å±æ€§
  addAttributes() {
    return {
      color: { default: '' }
    }
  }
  // ä»HTMLå†…å®¹åŠ è½½æ—¶å¦‚ä½•è§£æ
  parseHTML() {
    return [
      { tag: 'strong', },
    ]
  },
  ...schema, // ProseMirror.schemaå­—æ®µï¼Œå¦‚draggable
  ...
}
```

[å¦‚ä½•è‡ªå®šä¹‰æ‹“å±•ï¼Ÿ](https://tiptap.dev/guide/custom-extensions)

#### Markæ‹“å±•

```ts
import { Mark, mergeAttributes } from '@tiptap/core'

export const Underline = Mark.create({
  name: 'underline',
  addOptions() {
    return {
      HTMLAttributes: {},
    }
  },
  parseHTML() {
    return [
      { tag: 'u', },
      {
        style: 'text-decoration',
        consuming: false,
        getAttrs: style => ((style as string).includes('underline') ? {} : false),
      },
    ]
  },
  renderHTML({ HTMLAttributes }) {
    return ['u', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name)
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name)
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name)
      },
    }
  },
})
```

#### Nodeæ‹“å±•

```js
import { Node, mergeAttributes } from "@tiptap/core";

export default Node.create({
  name: "section",
  group: "block",
  content: "block+",

  addAttributes() {
    return {
      style: {
        parseHTML: (element) => element.style.cssText,
        renderHTML: (attributes) => ({ style: attributes.style }),
      },
    };
  },

  parseHTML() {
    return [{ tag: "section" }];
  },

  renderHTML({ HTMLAttributes }) {
    return ["section", mergeAttributes(HTMLAttributes), 0];
  },
});
```

### schema

Tiptap åŸºäºæ¨¡å¼å®šä¹‰å†…å®¹çš„ç»“æ„ã€‚è¿™æ ·å°±å¯ä»¥å®šä¹‰æ–‡æ¡£ä¸­å¯èƒ½å‡ºç°çš„èŠ‚ç‚¹ç±»å‹ã€å±æ€§ä»¥åŠåµŒå¥—æ–¹å¼ï¼›

ä¸èƒ½ä½¿ç”¨ä»»ä½•æœªåœ¨æ¨¡å¼ä¸­å®šä¹‰çš„ HTML å…ƒç´ æˆ–å±æ€§ã€‚

```js
import { Node } from '@tiptap/core'

const section = Node.create({
  name: 'section',
  content: 'block+',
  ...node schema
})

Mark.create({
  ...mark.schema
})
```

## Commands

é€šè¿‡tiptapä»¥åŠæ‹“å±•æä¾›çš„å‘½ä»¤(commands)ï¼Œå®ç°é€‰åŒºã€å†…å®¹çš„æ“ä½œ

**ç›´æ¥è°ƒç”¨**

```js
editor.commands.toggleBold();
editor.commands.toggleItalic();
```

**é“¾å¼è°ƒç”¨**

```js
editor
  .chain() // å¼€å¯é“¾å¼å‘½ä»¤
  .focus() // èšç„¦ç¼–è¾‘åŒºï¼Œé˜²æ­¢é€‰åŒºä¸¢å¤±
  .toggleBold() // è‹¥å¹²å‘½ä»¤é“¾æ¥ 
  .run() // è¿è¡Œå‘½ä»¤é“¾
```

## Editor

#### API

**updateAttributes**

```js
editor.chain().focus().updateAttributes("image", { float }).run();
```

**insertContent**

```js
editor.commands.insertContent({
  type: "image", // @tiptap/extension-image `name` é€‰é¡¹å€¼
  attrs: { src: "https://example.com/logo.png" },
});
editor
    .chain()
    .focus()
    .insertContent(emojiHTML, {
      parseOptions: {
        preserveWhitespace: false,
      },
    })
    .run();
```

æ›´å¤šè¯¦è§å®˜æ–¹æ–‡æ¡£

**getAttributes(type)**

```js
editor.getAttributes("textStyle").fontSize;
editor.getAttributes("paragraph")?.lineHeight;
```

**selectAll**

```js
editor.chain().focus().selectAll().setFontSize(`${size}px`).blur().run();
```

**setContent**

```js
editor.commands.setContent(newValue, false); // false å‚æ•°è¡¨ç¤ºä¸è®°å½•è¿™æ¬¡å˜æ›´åˆ°å†å²è®°å½•ä¸­
```

#### doc

**doc.descendantséå†æ–‡æ¡£**

```js
const { state } = this.editor;
const { schema, doc } = state;
const markType = schema.marks.textStyle;
const marksStyle = {
  marks: [],
  nodeMarks: [],
};
doc.descendants((node, pos) => {
  if (node.type.name === 'paragraph') {
    marksStyle.nodeMarks.push({ pos, attrs: node.attrs });
  }
  if (node.isText) {
    const currentMarks = node.marks.filter((mark) => mark.type === markType);
    if (currentMarks.length > 0) {
      currentMarks.forEach((mark) => {
        marksStyle.marks.push({
          pos,
          end: pos + node.nodeSize,
          attrs: mark.attrs,
        });
      });
    }
  }
});
```

#### state

**view.dispatch(tr) åº”ç”¨ä¿®æ”¹**

```js
const { state, view } = this.editor;
const { schema, tr } = state;
const markType = schema.marks.textStyle;
marksStyle.nodeMarks.forEach(({ pos, attrs }) => {
  const newAttrs = deepClone(attrs);
  if (attrs.letterSpacing) {
    const oldLetterSpacing = parseInt(attrs.letterSpacing);
    const letterSpacing = parseInt(oldLetterSpacing * ratio);
    newAttrs.letterSpacing = `${letterSpacing}px`;
  }
  if (attrs.lineHeight) {
    const oldLineHeight = parseFloat(attrs.lineHeight);
    const lineHeight = parseFloat((oldLineHeight * ratio).toFixed(1));
    newAttrs.lineHeight = lineHeight;
  }
  tr.setNodeMarkup(pos, null, newAttrs);
});
marksStyle.marks.forEach(({ pos, end, attrs }) => {
  const newAttrs = deepClone(attrs);
  if (attrs.fontSize) {
    const oldFontSize = parseInt(attrs.fontSize);
    const newFontSize = parseInt(oldFontSize * ratio);
    newAttrs.fontSize = `${newFontSize}px`;
  }
  const newMark = markType.create(newAttrs);
  tr.addMark(pos, end, newMark); // ä¼šè¦†ç›–åŸä½ç½®markçš„attrs
});
view.dispatch(tr);
```

### node

**node.type**ï¼šèŠ‚ç‚¹çš„ç±»å‹ä¿¡æ¯ï¼Œå¦‚ `node.type.name === 'paragraph'`

**node.isText/isTextBlock**ï¼šæ˜¯å¦ä¸ºæ–‡æœ¬èŠ‚ç‚¹/æ–‡æœ¬å—èŠ‚ç‚¹

**node.attrs**ï¼šèŠ‚ç‚¹çš„å±æ€§ï¼Œä¸€ä¸ªé”®å€¼å¯¹çš„å¯¹è±¡

**node.textContent**ï¼šèŠ‚ç‚¹çš„æ–‡æœ¬å†…å®¹ï¼ˆåŒ…æ‹¬æ‰€æœ‰å­èŠ‚ç‚¹çš„æ–‡æœ¬å†…å®¹ï¼‰

**node.marks**ï¼šèŠ‚ç‚¹çš„æ ‡è®°ï¼ˆä¾‹å¦‚åŠ ç²—ã€æ–œä½“ç­‰ï¼‰

## Extensions

å†…å®¹æ ·å¼å¤§éƒ¨åˆ†ç”± `marks` ç›´æ¥å®ç°ã€å¦‚åŠ ç²—é«˜äº®ç­‰ï¼Œä½¿ç”¨å¸¦æ ·å¼çš„ `mark` æ ‡ç­¾åŒ…è£¹å†…å®¹ï¼Œè°ƒç”¨å¯¹åº” commands å‘½ä»¤æ“ä½œï¼Œattribute æ ·å¼ä¿¡æ¯

æ–‡å­—æ ·å¼ç”± `text-style` è¿™ä¸€markå®ç°ï¼Œå¦‚æ–‡å­—é¢œè‰²å­—ä½“ç­‰ï¼Œä½¿ç”¨å¸¦æ ·å¼çš„ `span` æ ‡ç­¾åŒ…è£¹å†…å®¹ï¼Œè°ƒç”¨å¯¹åº” commands å‘½ä»¤æ“ä½œï¼Œattribute.textStyle æ ·å¼ä¿¡æ¯

### addNodeView

å¯¹renderHTMLæ‹“å±•ï¼ˆgetHTML å¯¼å‡ºæ—¶ï¼‰ï¼Œæ§åˆ¶å…·ä½“dom

// rendered: false



### 
