---
layout:     post
title:      Vue组件封装
subtitle:   封装满足特定需求的功能组件、包括自定义滚动条、自定义富文本编辑
date:       2021-06-18
author:     page
header-img: img/post-bg-swift2.jpg
catalog: true
tags:
    - Vue
---

# vue功能组件

## 自定义滚动条(mini-scroll)

**使用**

```html
<mini-scroll class="mini-scroll">
  <div class="content">...滚动内容撑开</div>
</mini-scroll>

<style lang="less" scoped>
.mini-scroll {
  width: 400px;
  height: 440px;
  border: 2px solid red;
  background-color: pink;
  .content {
    font-size: 35px;
    padding: 20px 40px 20px 20px;
  }
}
</style>
```

**组件**

```html
<template>
  <div class="mini-scroll scroll-container d-flex">
    <!-- 滚动视口容器 -->
    <div class="scroll-body flex-1" @scroll="scroll" ref="scrollBody">
      <!-- 滚动内容容器 -->
      <div class="scroll-content">
        <!-- 滚动内容插槽 -->
        <slot></slot>
      </div>
    </div>
    <!-- 滚动条容器 -->
    <div class="scroll-slide-container">
      <!-- 滚动条外层——包含了padding -->
      <div class="scroll-slide-bar w-100 h-100 absCenterY">
        <!-- 滚动条内层——滚动芯活动区域 -->
        <div class="scroll-inner h-100 bd-filt" ref="slideInner">
          <!-- 滚动芯 -->
          <div
            class="scroll-slider absCenterX w-100 bd-filt"
            :style="{
              height: `${sliderHeight}px`,
              transform: `translateY(${sliderY}px) translateX(-50%)`
            }"
            ref="slider"
            @touchstart="touchstart"
            @touchmove="touchmove"
          ></div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      ratio: 1, // 映射比例
      sliderHeight: 0, // 滚动芯高度
      startY: 0, // 滚动芯起始触摸Y值
      sliderY: 0 // 滚动芯滑动Y值
    };
  },
  mounted() {
    this.initScroll();
    this.scroll = this.UTILS.animationThrottle(this.scroll);
    this.touchmove = this.UTILS.animationThrottle(this.touchmove);
  },
  methods: {
    // 初始化 计算比例与初始化slider高度
    initScroll() {
      // 容器相关高度
      let clientHeight = this.$refs.scrollBody.clientHeight;
      let scrollHeight = this.$refs.scrollBody.scrollHeight;

      // 滚动条内部 滚动范围高度
      let slideInnerHeight = this.$refs.slideInner.clientHeight;

      // 计算比例与滚动芯高度
      this.ratio = slideInnerHeight / scrollHeight;
      this.sliderHeight = parseInt(this.ratio * clientHeight);
    },

    // 内容滚动 实时映射 slider位置
    scroll(e) {
      let $miniScroll = e.target;
      let scrollTop = $miniScroll.scrollTop;
      this.sliderY = scrollTop * this.ratio;
    },

    // 触摸滚动条
    touchstart(e) {
      let toucher = e.targetTouches[0];
      this.startY = toucher.clientY;
    },

    // 滑动滚动条
    touchmove(e) {
      let toucher = e.targetTouches[0];
      let touchY = toucher.clientY;
      let touchDistance = touchY - this.startY;
      let scrollTop = this.$refs.scrollBody.scrollTop;
      let nextTop = touchDistance / this.ratio + scrollTop;
      this.$refs.scrollBody.scrollTop = nextTop;
      this.startY = touchY;
    }
  }
};
</script>

<style lang="less" scoped>
.mini-scroll {
  position: relative;
  .scroll-body {
    height: 100%;
    scrollbar-width: none; /* firefox */
    -ms-overflow-style: none; /* IE 10+ */
    overflow-x: hidden;
    overflow-y: auto;
    &::-webkit-scrollbar {
      display: none; /* Chrome Safari */
    }
  }

  .scroll-slide-container {
    position: absolute;
    height: 100%; // 滚动条高度
    width: 20px; // 滚动条宽度
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    .scroll-slide-bar {
      box-sizing: border-box;
      padding: 39px 0; // 内层区域padding边距，控制可滑动区域和左右padding
      background-size: 100% 100%;
      .scroll-inner {
        position: relative;
        background-color: #eee;
        .scroll-slider {
          background-color: #fff;
        }
      }
    }
  }
}
</style>
```



## 折叠组件(collapse)

**使用**

```vue
<div
     class="chat-detail"
     v-collapse="{ max: 2, num: chat.messages.length }"
>
    <div class="item"></div>
    <div class="item"></div>
    ...
    <div class="collapse-switch">展开/折叠</div>
</div>
```

**命令参数**

- max：子项数超出max则开启折叠
- num：子项数
- initHeight：初始折叠状态高度(友好处理滚动条/内容闪动)

**指令**

```js
// 注册指令
directives: {
  collapse: {
    bind: v_collapse,
    componentUpdated: v_collapse,
    unbind(el){
      // 解绑命令时解绑折叠事件
      el.removeEventListener("click", collapseEvent);
    }
  }
}
// 折叠指令
function v_collapse(el, binding){
  var options = binding.value || {};
  const max = options.max || 0;   // 显示条数
  const num = options.num || 0;   // 当前总条数
  const initHeight = options.initHeight || "auto";   // 初始折叠高度
  if(num > max){
    // 默认折叠状态
    el.style.overflow = "hidden";
    el.dataset.collapsed = "collapsed";
    el.style.height = initHeight;
    var loading;
    var imgList = [].slice.call(el.querySelectorAll("img"));
    // 子项有img时，全部加载后才计算折叠高度
    if(imgList.length > 0){
      loading = Promise.all(
        imgList.map($img => new Promise(resolve => {
          $img.addEventListener("load", () => resolve());
          $img.addEventListener("error", () => resolve());
        }))
      )
    }else{
      loading = Promise.resolve()
    }
    loading.then(() => {
      // 计算折叠高度
      var collapsedHeight = []
        .slice.call(el.children, 0, max)
        .reduce((total, $ele) => total + $ele.clientHeight, 0);
      el.style.height = collapsedHeight + "px";
      el.dataset.collapsedHeight = collapsedHeight;
      el.addEventListener("click", collapseEvent);
    });
  }else{
    el.style.height = "auto";
    el.style.overflow = "unset";
  }
}

// 折叠事件
function collapseEvent(e){
  var el = e.currentTarget;
  var target = e.target;
  var list = [].slice.call(el.querySelectorAll(".collapse-switch"));
  var delegated = list.some($switch => $switch.contains(target));
  if(!delegated) return;
  // 切换折叠状态
  var collapsed = el.dataset.collapsed;
  var collapsedHeight = el.dataset.collapsedHeight + 'px' || 'auto';
  el.style.height = collapsed ? el.scrollHeight + 'px' : collapsedHeight;
  el.style.overflow = collapsed ? "unset" : "hidden";
  el.dataset.collapsed = collapsed ? "" : "collapsed";
}
```





## 预加载(loading-bar)

页面预加载静态资源，并用loading加载条实时显示加载进度；也可以做上传下载loading交互；

1. 生成预加载图片资源json

```js
// Node
var fs = require("fs");
var path = require("path"),
  filesList = {}, // 资源json
  imgPath = "../../assets/img", // 资源相对路径
  imgPathName = "ROOT"; // 当前读取层级，起始为ROOT

function readFileList(dir, dirName, filesList = {}) {
  const files = fs.readdirSync(dir);
  files.forEach(item => {
    const stat = fs.statSync(path.join(dir, item));
    if (stat.isDirectory()) {
      readFileList(`${dir}/${item}`, item, filesList);
    } else {
      if (!filesList[dirName]) {
        filesList[dirName] = [];
      }
      var fullPath = `${dir}/${item}`.replace(`${path.resolve(__dirname, imgPath)}/`, "");
      filesList[dirName].push(fullPath);
    }
  });
  return filesList;
}

readFileList(path.resolve(__dirname, imgPath), imgPathName, filesList);
let str = `
const imgList=${JSON.stringify(filesList)}
export default imgList
 `;
fs.writeFileSync(path.resolve(__dirname, "../../assets/js/imgList.js"), str);
```