---
layout:     post
title:      Java
subtitle:   
date:       2024-03-16
author:     page
header-img: img/Nuxt.png
catalog: true
tags:
    - Java
    - 
---

# Java

## 简介

**广泛应用的 Java**

- Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行；

- Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理；

- Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验；

- Java拥有最广泛的开源社区支持，各种高质量组件随时可用。

**作者**：SUN公司（已被Oracle收购）的 [詹姆斯·高斯林](https://en.wikipedia.org/wiki/James_Gosling)

**一次编写，到处运行**

Java介于编译型语言和解释型语言之间，将代码编译成一种“字节码”，它类似于抽象的CPU指令；然后，针对不同平台编写虚拟机，不同平台的虚拟机(JVM)负责加载字节码并执行；对Java开发者而言，实现了一次编写，到处运行

**Java版本**

- Java ME：针对嵌入式设备的“瘦身版”

- Java SE：标准版，包含标准的JVM和标准库

- Java EE：企业版，Java SE基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务

**JRE**：运行Java字节码的虚拟机（Java Runtime Environment）

**jdk**：要编译成Java字节码还需JDK（Java Development Kit），JDK包含JRE，还提供了编译器、调试器等开发工具

```ascii
 ┌─    ┌──────────────────────────────────┐
  │     │     Compiler, debugger, etc.     │
  │     └──────────────────────────────────┘
 JDK ┌─ ┌──────────────────────────────────┐
  │  │  │                                  │
  │ JRE │      JVM + Runtime Library       │
  │  │  │                                  │
  └─ └─ └──────────────────────────────────┘
        ┌───────┐┌───────┐┌───────┐┌───────┐
        │Windows││ Linux ││ macOS ││others │
        └───────┘└───────┘└───────┘└───────┘
```

**JSR规范**：Java平台功能规范，从JVM的内存模型到Web程序接口（Java Specification Request），它由JCP组织审核

## 安装

### JDK

[Oracle的官网](https://www.oracle.com/java/technologies/downloads/)下载对应稳定版JDK：[Java Downloads | Oracle](https://www.oracle.com/java/technologies/downloads/)

**设置环境变量**

java 1.5后无需手动设置环境，如需要可在系统环境变量新增

`Path=%JAVA_HOME%\bin;<现有的其他路径>`

**运行**：`java -version` 尝试查看版本

### 程序代码

```java
// Hello.java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

Java规定，某个类定义的 `public static void main(String[] args)` 是Java程序的固定入口方法，必须定义为 `public` 类型的静态class，Java程序总是从`main`方法开始执行

文件名必须与类名完全保持一致

**运行代码**

通过 javac 将 `.java` 文件编译成 `.class` 字节码文件：`javac Hello.java`

虚拟机执行字节码文件，将自动寻找参数对应 `.class` 文件：`java Hello`

或者直接 `java Hello.java`

## Java基础

### 程序基本结构

Java是面向对象的语言，一个程序的基本单位就是 `class`，`class` 是关键字，这里定义的 `class` 名字就是 `Hello`

```java
public class Hello { // 类名是Hello
    // ...
} // class定义结束
```

若无 `public`，也能正确编译，但是这个类将无法从命令行执行

`class`内部，可以定义若干方法（method）：

```java
public class Hello {
    public static void main(String[] args) { // 方法名是main
        // 方法代码...
    } // 方法定义结束
}
```

### 变量与数据类型

声明变量：`int a = 100; int b`

变量赋值：`a = 200; int c = a; `

**基本数据类型**

- 整数类型：byte，short，int，long

- 浮点数类型：float，double

- 字符类型：char

- 布尔类型：boolean

**整型**

```java
int i2 = -2147483648;
int i3 = 2_000_000_000; // 加下划线更容易识别
int i4 = 0xff0000; // 十六进制
long n1 = 9000000000000000000L; // long型的结尾需要加L
long n2 = 900; // 此处900为int，但int类型可以赋值给long
int i6 = 900L; // 错误：不能把long型赋值给int
```

**浮点型**

```java
float f1 = 3.14f;
float f2 = 3.14e38f; // 科学计数法表示的3.14x10^3
double d = 1.79e308;
double d2 = -1.79e308;
double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-3248
```

**布尔类型**

```java
boolean b1 = true;
boolean b2 = false;
boolean isGreater = 5 > 3; // 计算结果为true
```

**字符串类型**

**字符类型**

```java
char a = 'A'; // 单引号 '
```

**字符串类型**

```java
String s = "hello";
```

**常量**

```java
final double PI = 3.14; // final 修饰符
```

**var 关键字**

赋值语句自动推断出变量的类型：

```java
var sb = new StringBuilder();
StringBuilder sb = new StringBuilder();
```

**作用域**

java存在块级作用域，以 `{}` 为分隔

### 基础运算

**整数运算**

整数运算永远返回整数

```java
int x = 12345 / 67; // 184
int y = 12345 % 67; // 12345÷67的余数是17
```

参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，`short` 和`int` 计算，结果总是 `int`

也支持强制转型：

`short s = (short) i; // 12345`

`int n3 = (int) (12.7 + 0.5); // 13`

**字符串运算**

\ 转义

```java
String s = "abc\"xyz"; // 包含7个字符: a, b, c, ", x, y, z、
// \n 换行
```

多行字符串

```java
String s = """
           SELECT * FROM
             users
           WHERE id > 100
           ORDER BY name DESC""";
```

### 数组类型

一组相同类型的变量

```java
int[] ns = new int[3]; // 一组字符串的数组
ns[0] = 68;
ns[1] = 79;
ns[2] = 91;
System.out.println(ns[3]); // 索引n不能超出范围
```

直接初始化

```java
ns = new int[] { 68, 79, 91, 85, 62 };
// 简化为
int[] ns = { 68, 79, 91, 85, 62 };
String[] names = {
    "ABC", "XYZ", "zoo"
};
```

## 流程控制

### 输入输出

**输出方法**

`System.out.print()`

`System.out.println()` 输出并换行

`System.out.printf(f, String)` 格式化输出

**格式化输出**

指定输出内容格式，并传入参数得到格式输出结果

```java
public class Hello {
    public static void main(String[] args) {
        double num = 3.1415926;
        System.out.printf("%.2f\n", num); // 3.14
    }
}
```

| 占位符 | 说明               |
| --- | ---------------- |
| %d  | 格式化输出整数          |
| %x  | 格式化输出十六进制整数      |
| %f  | 格式化输出浮点数         |
| %e  | 格式化输出科学计数法表示的浮点数 |
| %s  | 格式化字符串           |

### 条件语句

**判断变量值相等**

```java
int n = 90;
if(n == 90) {
  ...
}
```

**判断引用相等**

```java
String s1 = "hello";
String s2 = "HELLO".toLowerCase();
if (s1 == s2) {
    System.out.println("s1 == s2");
} else {
    System.out.println("s1 != s2");
}
```

**判断引用类型值相等**

```java
s1.equals(s2); // s1 为 null则会报错 NullPointerException
```

### 多重选择

**switch**

除了基础 switch 语法，还有表达式语法

```java
public static void main(String[] args) {
    int n = 90;
    String result = switch(n){
        case 10 -> "is 10"; // 直接返回
        case 90 -> "is 90";
        default -> {
            yield "is 999"; // yield关键字
        }
    };
    System.out.println(result);
}
```

### 循环

while/do while/ for

## 数组操作

### 遍历数组

```java
int[] list = { 6, 6, 6, 1, 8 };
for (int i = 0;i < list.length;i++) {
    System.out.println(list[i]);
}
```

`for each` 循环，迭代数组的每个元素

```java
int[] list = { 6, 6, 6, 1, 8 };  
for (int num : list) {
    System.out.println(num);
}
```

快速打印数组内容为字符串

```java
import java.util.Arrays; // Java标准库提供
...
int[] ns = { 1, 1, 2, 3, 5, 8 };
System.out.println(Arrays.toString(ns));
```

### 数组排序

**冒泡排序**

**内置sort**

只需调用JDK提供的 `Arrays.sort()`，注意这将修改数组

### 多维数组

```js
int[][] ns = {
   { 1, 2, 3, 4 },
   { 5, 6, 7, 8 },
   { 9, 10, 11, 12 }
};

Arrays.deepToString(ns);
```

### 命令行参数

Java程序的入口是 `main` 方法，接受一个命令行参数，一个 `String[]` 数组；

```java
import java.util.Arrays;

public class Main {
public static void main(String[] args) {
    System.out.println(Arrays.toString(args));
}
}
```

## 面向对象

**定义类基础**

类与实例的关系，如定义一个 City 类并使用

```java
public class Main {
public static void main(String[] args) {
    City changsha = new City();
    changsha.name = "changsha";
    changsha.latitude = 42.09;
    changsha.longitude = 122.92;
    System.out.println(changsha.name);
    System.out.println(changsha.latitude);
    System.out.println(changsha.longitude);
}
}

class City {
    public String name;
    public double latitude;
    public double longitude;
}
```

**注**：一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。

### 方法

**定义方法**

```java
public String name;
public String getName() {
   return this.name; // this指向实例
}

System.out.println(changsha.getName());
```

**定义方法修改/访问私有 field**

```java
private int age;
public void setAge(Int age) {
  this.age = age;
}

changsha.setAge(200);
System.out.println(changsha.getAge());
```

**定义内部的私有方法**

```java
private int birthYears;
public void setBirthYears(int birthYears) {
    this.birthYears = birthYears;
}
public int getAge() {
    return calcAge(); // 可忽略this
}
private int calcAge(){
    return 2024 - this.birthYears;
}

changsha.setBirthYears(-376);
System.out.println(changsha.getAge());
```

**参数**

严格按照参数定义传递

```java
public void setNameAndAge(String name, int age) {
  ...
}
Person ming = new Person();
ming.setNameAndAge(12, "Xiao Ming"); // 参数数量
```

可变参数

```js
public void setNames(String... names) { // ...可变参数
   this.names = names; // 数组类型
}

Group g = new Group();
g.setNames("Xiao Ming", "Xiao Hong", "Xiao Jun"); // 传入3个String
```

### 构造方法

允许指定构造方法初始化实例，未指定将生成空构造函数

```java
class City {
  public City(String name, double latitude, double longitude, int birthYears){
    this.name = name;
    this.latitude = latitude;
    this.longitude = longitude;
    this.birthYears = birthYears;
  }
  // ...
}

City changsha = new City("changsha", 42.09, 122.92, -376);
```

构造方法的名称就是类名，且没有返回值（也没有 `void`）；

调用构造方法，必须用 `new` 操作符；

构造方法中初始化字段时，引用类型的字段默认是 `null`

```java
class Person {
    private String name; // 默认初始化为null
    private int age; // 默认初始化为0

    public Person() {
    }
}
```

或者直接初始化

```java
private String name = "Unamed";
private int age = 10;
```

**多构造方法**

根据构造方法的参数数量、位置和类型自动区分

```java
public Person(String name, int age) {
   this.name = name;
   this.age = age;
}

public Person(String name) {
   this.name = name;
   this.age = 12;
}

public Person() {
}
```

### 方法重载

方法名相同，但各自的参数不同

- `int indexOf(int ch)`：根据字符的Unicode码查找；

- `int indexOf(String str)`：根据字符串查找；

- `int indexOf(int ch, int fromIndex)`：根据字符查找，但指定起始位置；

- `int indexOf(String str, int fromIndex)`根据字符串查找，但指定起始位置。

### 继承

**extends**

```java
class Student extends Person {
    // 不要重复Person父类的字段/方法,
    private int score;

    public int getScore() { … }
    public void setScore(int score) { … }
}
```

**protected**

父类 `private` 方法无法被子类继承，通过 `protected` 允许子类继承私有方法

```java
class Person {
    protected String name;
    protected int age;
}
```

**super**

即父类构造方法，默认子类构造方法将补充 `super()`；当父类构造方法为参数方法，须手动编写

```java
class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        super(name, age); // 调用父类的构造方法Person(String, int)
        this.score = score;
    }
}
```

**阻止继承**

sealed 支持阻止继承的类：`public sealed class Shape`

permits 明确可继承子类名称：`public final class Rect extends Shape {...}`

**注**：`sealed`类在Java 15中目前是预览状态，要启用它，必须使用参数`--enable-preview`和`--source 15`。

**向上/向下转型**

是把一个子类型安全地变为更加抽象的父类型：

```java
Student s = new Student();
Person p = s; // upcasting, ok
Object o1 = p; // upcasting, ok
Object o2 = s; // upcasting, ok
```

相反向下转型往往失败

```java
Person p1 = new Student(); // upcasting, ok
Person p2 = new Person();
Student s1 = (Student) p1; // ok
Student s2 = (Student) p2; // runtime error! ClassCastException!
```

**instanceof**

`p instanceof Student`

`obj instanceof String`

`obj instanceof String s` 若满足，可以直接使用变量s（Java14支持）

### 多态

**Override/Overload**

子类覆写与父类方法签名完全相同的方法

```java
class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

与 Override不同，Overload 适用于同名称新方法（参数与返回值不同）覆写的情况

```java
Person p = new Student();
```

实际类型为 `Student`，引用类型（变量声明类型）为 `Person` 调用 `run()` 的结果说明：

Java 基于运行时的实际类型的动态调用，而非变量的声明类型。这就是面向对象的**多态**特性

可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。

**final**

用 `final` 修饰的方法不能被 `Override`

```java
class Person {
    protected String name;
    public final String hello() {
        return "Hello, " + name;
    }
}
```

用 `final` 修饰的类不能被继承，除非通过 `permits` 额外指定

```java
final class Person {
    protected String name;
}
```

### 抽象类

多态的存在，每个子类都可以覆写父类的方法；这要求父类必须声明具体子类可覆写方法；如 `public void run() { … }`

**abstract**

`abstract` 表示它是一个抽象方法，本身没有实现任何方法语句，本身无法执行；

此外包含抽象方法的类，也需要声明 `abstract` 即抽象类，且它无法被实例化；

```java
abstract class Person {
    public abstract void run();
}
```

抽象类本身被设计成只能用于被继承，强迫子类实现其定义的抽象方法，因此抽象方法实际上相当于定义了**“规范”**

面向抽象编程的本质就是：

- 上层代码只定义规范（例如：`abstract class Person`）；

- 不需要子类就可以实现业务逻辑（正常编译）；

- 具体的业务逻辑由不同的子类实现，调用者并不关心。 

### 接口

一个抽象类没有字段，所有方法全部都是抽象方法：

```java
abstract class Person {
    public abstract void run();
    public abstract String getName();
}
```

**interface**

把该抽象类改写为接口 `interface`，定义接口规范

```java
interface Person {
    void run();
    String getName();
}
```

即比抽象类还要抽象的纯抽象接口，不允许字段。且接口定义的所有方法默认都是 `public abstract`

**implements**

对一个具体的 `class` 去实现一个 `interface`，且一个class允许是多个 `interface` 实现

```java
class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + " run");
    }

    @Override
    public String getName() {
        return this.name;
    } 
}
```

```java
class Student implements Person, Hello { // 实现了两个interface
    ...
}
```

Java的接口特指`interface`的定义，表示一个接口类型和一组方法签名

而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。

抽象类和接口的对比如下：

|       | abstract class   | interface               |
| ----- | ---------------- | ----------------------- |
| 继承    | 只能extends一个class | 可以implements多个interface |
| 字段    | 可以定义实例字段         | 不能定义实例字段                |
| 抽象方法  | 可以定义抽象方法         | 可以定义抽象方法                |
| 非抽象方法 | 可以定义非抽象方法        | 可以定义default方法           |

**接口继承**

通过 `extends` 实现一个`interface`可以继承自另一个`interface`，它相当于扩展了接口的方法

合理设计`interface`和`abstract class`的继承关系，可以充分复用代码。

一般来说，公共逻辑适合放在`abstract class`中，具体逻辑放到各个子类，而接口层次代表抽象程度。

**default方法**

`default` 方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

```java
interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}
```

## Java核心类

### 枚举类

使用`enum`来定义枚举类实现检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用；

```java
public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day == Weekday.SAT || day == Weekday.SUN) {
            System.out.println("Work at home!");
        } else {
            System.out.println("Work at office!");
        }
    }
}

enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
```

枚举类相对于分散的、无类型的常量优势：

- `enum`常量本身带有类型信息，编译器对比值会自动检查出类型错误

- 不可能引用到非枚举的值，因为无法通过编译

- 不同类型的枚举不能互相比较或者赋值，因为类型不符

`enum`定义的枚举类，内部本质是`class`



## 集合Collection

由若干个确定的元素所构成的整体，便于处理一组类似的数据；

一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，这种Java对象称为集合，如数组 `int[] arr = {1, 2, 3}`

数组作为集合特点包括

- 数组初始化后大小不可变；
- 数组只能按索引顺序存取。

除了数组，Java提供更多不同特性的集合类处理不同数据

- 可变大小的顺序链表；
- 保证无重复元素的集合；
- ...

**Collection**

Java标准库自带的 `java.util` 包提供了集合类，除 `Map` 外所有其他集合类的根接口

**特点**：

实现了接口和实现类相分离，例如，有序表的接口是 `List`，具体的实现类有 `ArrayList`，`LinkedList` 等

支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：

```java
List<String> list = new ArrayList<>(); // 只能放入String类型
```

`java.util`包主要提供了以下三种类型的集合：

- `List`：一种有序列表的集合；如按索引排列的 `Student` 的`List`；
- `Set`：一种保证没有重复元素的集合；如所有无重复名称的 `Student` 的 `Set`；
- `Map`：一种通过键值（key-value）查找的映射表集合；如根据 `Student` 的 `name` 查找对应 `Student` 的 `Map`。

### List

一种有序列表，最基础的集合

**ArrayList**

数组添加和删除元素时非常不方便（可访问），对于增删元素的有序列表，使用最多的是`ArrayList`

`ArrayList`把添加和删除的操作封装起来，让我们操作`List`类似于操作数组，不用关心内部元素如何移动

`List<E>` 接口，可以看到几个主要的接口方法：

- 在末尾添加一个元素：`boolean add(E e)`
- 在指定索引添加一个元素：`boolean add(int index, E e)`
- 删除指定索引的元素：`E remove(int index)`
- 删除某个元素：`boolean remove(Object e)`
- 获取指定索引的元素：`E get(int index)`
- 获取链表大小（包含元素的个数）：`int size()`

**LinkedList**

List接口除了数组实现（ArrayList）,还有链表实现（LinkedList）

**创建List**

通过`List`接口提供的`of()`方法，根据给定元素（不包括null）快速创建`List`

```java
import java.util.List;

List<Integer> list = List.of(1, 2, 5);
```

**迭代List**

如果你需要迭代List， `Iterator` 是最好的方式

`Iterator`本身也是一个对象，但它是由`List`的实例调用`iterator()`方法的时候创建的

不同的`List`类型，返回的`Iterator`对象实现也是不同的，但总是具有最高的访问效率。

```java
import java.util.Iterator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("apple", "pear", "banana");
        for (Iterator<String> it = list.iterator(); it.hasNext(); ) {
            String s = it.next();
            System.out.println(s);
        }
    }
}
```

实现了`Iterable`接口的集合类都可以直接用`for each`循环来遍历，会自动把`for each`循环变成`Iterator`的调用

```java
// 更简洁的代码
for (String s : list) {
  System.out.println(s);
}
```

**List转换Array**

```java
List<Integer> list = List.of(12, 34, 56);
Number[] array = list.toArray(new Number[3]); // 注意此处支持new Number，非强制 new Integer
for (Number n : array) {
    System.out.println(n);
}
```

如果传入的数组不够大，那么`List`内部会创建一个新的刚好够大的数组，填充后返回；

如果传入的数组比`List`元素还要多，那么填充完元素后，剩下的数组元素一律填充`null`。

最常用的是传入一个“恰好”大小的数组：

```java
Integer[] array = list.toArray(new Integer[list.size()]);
```

更简洁的写法是通过`List`接口定义的`T[] toArray(IntFunction<T[]> generator)`方法：

```java
Integer[] array = list.toArray(Integer[]::new);
```

**Array转换List**

```java
Integer[] array = { 1, 2, 3 };
List<Integer> list = List.of(array);
// 或
List<Integer> list = Arrays.asList(array); // JDK 11之前的版本
```

注：`List.of()` 返回的是一个只读 `List`，

### Map

键值（key-value）映射表的数据结构（无固定顺序）

```java
import java.util.HashMap;
import java.util.Map;

Map<String, Student> map = new HashMap<>();
map.put("Xiao Ming", s); // 将"Xiao Ming"和Student实例映射并关联
Student target = map.get("Xiao Ming"); // 通过key查找并返回映射的Student实例

map.containsKey("Xiao Ming");
```

**遍历 Map**

通过对 `keySet()` 方法返回的 `Set` 集合 for each 遍历

```java
for (String key : map.keySet()) {
  Integer value = map.get(key);
  System.out.println(key + " = " + value);
}
```

通过对 `entrySet()` 方法返回每一个`key-value`映射的集合，同时遍历 key value

```java
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    String key = entry.getKey();
    Integer value = entry.getValue();
    System.out.println(key + " = " + value);
}
```

**TreeMap**

一种对Key进行排序 `Map` 即 `SortedMap`， `SortedMap` 是接口，它的实现类即 `TreeMap`

```java
Map<String, Integer> map = new TreeMap<>();
```

创建`TreeMap`时，放入的Key必须实现`Comparable`接口

对于`String`、`Integer`这些类已经实现了`Comparable`接口，可以直接作为Key使用

对于没有`Comparable`接口，则必须在创建`TreeMap`时同时指定一个自定义排序算法

```java
Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {
    public int compare(Person p1, Person p2) {
        return p1.name.compareTo(p2.name);
    }
});
Map<Student, Integer> map = new TreeMap<>(new Comparator<Student>() {
    // 必须考虑相等时返回0
    if (p1.score == p2.score) {
        return 0;
    }
    public int compare(Student p1, Student p2) {
        return p1.score > p2.score ? -1 : 1;
    }
});
```

### Set

存储不重复的元素集合，它主要提供以下几个方法：

- 将元素添加进`Set<E>`：`boolean add(E e)`
- 将元素从`Set<E>`删除：`boolean remove(Object e)`
- 判断是否包含元素：`boolean contains(Object e)`

**HashSet**

对`HashMap`的简单封装

```java
Set<String> set = new HashSet<>();
```

`Set` 接口并不保证有序，而 `SortedSet` 接口则保证元素是有序的：

- `HashSet`是无序的，因为它实现了`Set`接口，并没有实现`SortedSet`接口；
- `TreeSet`是有序的，因为它实现了`SortedSet`接口。

`TreeSet`和使用`TreeMap`的要求一样，添加的元素必须正确实现`Comparable`接口
