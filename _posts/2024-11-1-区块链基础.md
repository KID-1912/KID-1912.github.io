---
layout:     post
title:      区块链基础
subtitle:   什么是区块链———通过后一个区块对前一个区块的引用，并以加密技术保证了区块链不可修改
date:       2024-11-1
author:     page
header-img: img/blockchain.jpg
catalog: true
tags:
    - web3
---

# 区块链基础

区块链（Blockchain）技术源于 [比特币](https://bitcoin.org/en/)。为了保证每笔交易可信并不可篡改，它通过后一个区块对前一个区块的引用，并以加密技术保证了区块链不可修改。

**本质**：一个分布式的，不可篡改的数据库；

**特性**：天生具有可验证、可信任的特性

**用途**：不但可用于支持比特币等**数字货币**，也可用于**数字身份验证**，**清算业务**等传统的必须由第三方介入的业务，从而降低交易成本（当然也增加了另一些成本）。

## 区块链原理

区块链是由一个一个区块构成的**有序链表**

## 区块

- 记录了一系列交易

- 有唯一哈希标识，即**block hash**（区块哈希），根据区块头部内容（区块头信息）生成

- 区块头部**Prev Hash**字段指向上一个区块

- 区块头部**Merkle Hash**即交易内容生成的hash

**Hash算法**

比特币涉及 SHA-256，RipeMD160 算法，采用 SHA-256 + SHA-256 和 SHA-256 + RipeMD160 两种加密算法；

## 不可篡改

如果一个恶意的攻击者修改了一个区块中的某个交易，那么**Merkle Hash验证**就不会通过。

所以，他只能重新计算Merkle Hash，然后把区块头的Merkle Hash也修改了。

这时，我们就会发现，这个区块本身的Block Hash就变了，所以，下一个区块指向它的链接就断掉了。

因此，攻击者必须先**重新计算这个区块的Block Hash**，然后，再把后续所有区块全部重新计算并且伪造出来，才能够修改整个区块链。

## P2P交易

无需信任中介参与的P2P（Peer-to-peer点对点）交易，传统交易实际上并没有完成货币转移；

### 数字签名

通过数字签名算法（非对称加密算法），证明交易信息有效；

对某个消息签名的时候，主体使用私钥对消息进行签名（加密），然后，把消息、签名和自己的公钥发送出去；

其他任何人都可以通过主体的公钥对这个签名进行验证（解密），如果验证通过，可以肯定该消息是特定发出的；

**特性**：

- 防伪造：签名不可伪造；因为私钥只有签名人自己知道，所以其他人无法伪造签名

- 防篡改：消息不可篡改；如果原始消息被人篡改了，那么对签名进行验证将失败

- 防抵赖：签名不可抵赖；如果对签名进行验证通过了，那么该消息肯定是由签名人自己发出的

### 非对称加密算法

RSA算法，DSA算法和ECDSA算法，比特币采用 ECDSA 算法（椭圆曲线签名算法）

### 钱包软件

帮助用户管理私钥的软件，包括：

- 本地钱包：是把私钥保存在本地计算机硬盘上的钱包软件，如[Electrum](https://electrum.org/)；
- 手机钱包：和本地钱包类似，但可以直接在手机上运行，如[Bitpay](https://bitpay.com/)；
- 在线钱包：是把私钥委托给第三方在线服务商保存；

### 交易

每个区块都记录了至少一笔交易，一笔交易就是把一定金额的比特币从一个输入转移到一个输出（记账）

交易双方：双方的公钥地址

交易记录：比特币协议规定一个输出必须一次性花完；一个交易中，一个输入可以对应多个输出，一个交易也可以对应多个输入和1个输出

比特币实际的交易记录是由一系列交易构成，每一个交易都包含一个或多个输入，以及一个或多个输出。未花费的输出被称为UTXO：Unspent Transaction Ouptut。

总结：Hash算法保证了区块数据的完整性和顺序性（加密），数字签名保证了交易信息有效性（背书）；

## 挖矿原理

挖矿的本质就是【打包区块】（将待处理的 交易数据打包），它是区块链工作流程之一；

通过工作量证明+hash碰撞+共识算法/机制，解决区块链以下问题：

1. 每个节点都能将交易打包区块，会出现伪造身份的大量节点干扰/操纵系统（假设以多数节点投票”来决定交易顺序），即女巫攻击；

2. 双花攻击：一个节点能够同时将2个spend交易打包区块（一钱两花），使不同节点看到不同交易顺序，但最终只有一个有效；

3. 激励作用：生成新币还能共同维护；

### 工作量证明机制（POW）

**解决方案核心**：让节点打包区块都需要消耗真实算力

在被打包区块的头部有 bits （4字节长度表示一个Hash）的值，用于表示区块难度值，要求被打包区块Block Hash最终小于该值（要求以n个0开头）；

允许矿工调整区块头部的Nonce（随机数）值，通过Hash碰撞计算出符合难度值的Hash，验证后即可打包区块到链；

**其他规则**：

难度值变化：防止算力波动导致打包区块速度变化，比特币以10分钟为标准，自动增加/减少难度；

无法抄袭盗取：即时矿工打包了完全相同的交易列表，但他们的Coinbase地址（收取奖励的地址）不同，以及Nonce尝试的顺序不同，他们最终计算的符合难度值对的Block Hash不同（答案不同）。​

### 共识算法

目的：解决状态分叉（分叉链），如自然分叉（矿工同时挖出符合区块难度值Hash）与恶意攻击分叉（双花交易的2个区块，同时生成的2笔spend交易被打包到各链）

**解决方案核心**：“最长链规则”，节点收到比自己更长的有效链认定为主链；

## 账户模型UTXO

交易它允许由若干个输入（Input）和若干个输出（Output）构成；

**余额**

无法通过某个账户直查余额，而是通过计算此人控制的所有UTXO金额之和。

钱包程序必须从创世区块开始扫描每一笔交易（这就是为什么扫描前无法知余额），如果：

1. 遇到某笔交易的某个Output是钱包管理的地址之一，则钱包余额增加；
2. 遇到某笔交易的某个Input是钱包管理的地址之一，则钱包余额减少。

钱包程序避免每次查询实现瞬时查询，扫描区块链维护关系数据库-余额映射表；

## 可编程支付原理

**解锁脚本**：进行花费（拿钱）动作，构造引用一个UTXO并提供解锁脚本scriptSig的**输入**，它包含（提供）公钥和当前交易的签名，将在打包到区块时被矿工执行验证；

**锁定脚本**：进行支付（给钱）动作，由支付者添加一个含锁定脚本scriptPubKey的**输出**，它将被包含进区块成为一个UTXO，此时支付行为已被确认；

**执行细节**：

​​收款方​​决定接收规则： 根据需求(P2PKH/P2SH/多签)​**​生成锁定脚本模板​**​ -> 根据脚本​**​生成收款地址​**​ -> 将地址发送给付款方。

​​付款方​​：收到地址 -> ​**​解码地址，得到核心数据​**​（哈希值）-> ​**​利用该数据构造出正确的锁定脚本​**(填入哈希值)​ -> 将该脚本添加到交易输出中，创建UTXO

​**​所有权与消费权分离​**​：

​**​解锁脚本（证明）​**​ 在花费时才提供，证明​**​我满足消费条件​**​。它只在交易广播时临时存在，验证后即被丢弃（但存在于链上）。

​**​锁定脚本（规则）​**​ 在支付时就被永久固定在区块链上，定义了​**​谁能花这笔钱​**​（消费条件）。

**P2PKH**：支付给公钥哈希（Pay to Public Key Hash），通过验证签名与公钥哈希的匹配来支付

### 多重签名

**问题**：单点控制的风险，失去单个私钥则无法花费

**场景**：

- 个人资金安全​：密钥丢失，采用其他备份密钥（1-3或2-3）

- 公司或组织财库：5个董事中的3个签名才能动用资金 （防止单一人员掌控资金或携款跑路；确保重大支出需要集体决策）

- 联合托管：第三方作为仲裁者：买家、卖家、仲裁方。交易顺利完成时，买家和卖家签名支付。出现纠纷时，仲裁方与其中一方签名裁决。（解决买卖双方互不信任的问题。）

- 服务商盗取：服务商倒闭或者被黑客攻击，用户可使用自己掌握的两个私钥转移资金。(2-3)

**Multisig**

**解锁脚本**：为支付方时提供多个公钥和对应签名，然后验证m-n规则

**锁定脚本**：为收款方时使用生成的多个公钥创建PublicScriptKey

## SegWit地址

隔离见证（Segregated Witness）地址，以`bc`开头的地址；

**问题**：ECDSA允许计算出两个有效的签名，并且这两个有效的签名还可以互相计算出来；存在延展性攻击风险；

**解决**：不同之处是签名数据移到交易之外，并通过Bech32编码地址，修改签名​**​不会改变​**​核心的 `txid`；

## HD钱包

**问题**：出于隐私性目的，我们希望用户控制的UTXO其地址不同（否则从地址获知某个用户的比特币持币总额），但为此每次收款使用不同地址，意味着管理成千上万私钥，无法管理

**解决**：用一个私钥管理成千上万个地址；分层（Hierarchical Deterministic），使用主私钥生成逐层拓展私钥，只用主公钥生成逐层公钥（扩展公钥无需主私钥参与生成）；

**作用**：备份一个主私钥/存储一个主公钥即可生成若干地址；方便审计，通过主公钥或任一拓展公钥，就能查看其下级交易记录与UTXO汇总值；

**交易过程**：1. 预先推导常用路径；2. 维系密钥库，包含所有生成过的地址和该地址完整路径；3. 收款时从密钥库取出下一个未使用派生路径，配合主公钥得到收款地址；4. 花费时取出UTXO的地址，从密钥库查出对应路径，配合主私钥实时计算正确扩展私钥签名花费交易；

**安全性**：暴露一个私钥，就会泄露整个树状密钥；使用硬化衍生（强制子私钥计算仅依赖父私钥）而与主公钥无关；

**分层的多签**：生成一个长期有效的多签公钥，付款时使用多签地址，收款和找零时使用普通地址，后续普通地址转多签地址（类似收银台转金库）

### 助记词

**问题**：HD钱包生成私钥都依赖随机数，随机数（种子）生成主私钥，那么避不开记忆或存储它们之一；

**期望**：为了方便人的易抄写、易记忆、易理解、易校验；期望通过一串单词/文字实现最终私钥推导(有了它就有了私钥)；

**实现**：通过助记词库，将生成的随机数解析为索引从助记词库取出对应助记词；助记词生成种子生成私钥实现固定推导；在生成种子时配合口令(password)实现双因素验证；

## 以太坊

以太坊的节点们通过虚拟机EVM运行智能合约，它将字节码转操作码执行；

**账户模型**：以太坊区别于比特币UTXO，采用余额模型；

**智能合约**：

比特币的链上交易看做数字游戏，通过验证后的解锁/锁定脚本的交易来记录数字的变化（实现UTXO扭转）

以太坊则将链上交易看做任意状态的变化，通过区块链上可实现状态转化的合约实现状态的自定义变化；

**以太坊账户**

一个以太坊账户由外部账户+合约账户

外部账户即普通用户的私钥对应的账户；合约账户即合约代码的账户，无所有权无私钥匹配；

**账户数据**

一个以太坊账户由4部分构成：

- nonce：一个递增的整数，每发送一次交易nonce加一，因此它记录了交易的次数；

- balance：账户余额，以 wei 为单位；

- storageRoot：存储合约相关的状态数据（外部账户无改该）；

- codeHash：存储合约代码的Hash

**区块结构**

Merkle Patricia Tree 在区块上存储状态，其中生成的stateRoot生成世界状态；

**区块数据**

交易状态：transactionRoot MPT树

回执状态：receiptsRoot MPT树

**交易**

普通转账交易

智能合约交易

gas费：节点EVM运行的成本作为交易费；消耗CPU比消耗存储便宜，简单计算比复杂计算便宜，读取比写入便宜；

**交易回执**

以太坊区块为每一块交易都会产生一笔回执（Recipt）,表示交易的最终状态。一个回执信息主要包括：

- status：执行结果，1 表示成功，0 表示失败；

- gasUsed：已消耗的Gas数量

- txHash：交易Hash

- logs：交易产生的日志

**智能合约**
