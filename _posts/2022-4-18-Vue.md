---
layout:     post
title:      Vue
subtitle:   Vue.js——渐进式、响应式、组件化
date:       2022-4-18
author:     page
header-img: img/home-bg-art.jpg
catalog: true
tags:
    - vue
---

# Vue

## v-model

`v-model`能够在表单元素上快速创建数据双向绑定(语法糖)，不同表单元素代理对应input、change事件；

如果用于组件(component)上，则默认添加名为value的prop值传递，以及监听内部input事件；

### 自定义model

允许在子元素内对model自定义prop与事件通信；

```
export default {
    model: {prop: 'userProfile', event: 'submit' },
    props: ['userProfile'],
    methods: {
        onSubmit(form) {
            this.$emit('submit', form);
        }
    }
}
```

### 指令修饰符

- v-model.trim
- v-model.number
- v-model.lazy

## computed

计算属性(由多个属性值固定计算出的属性值)

get/set控制

```js
set(item) {
  this.data.push(item);
},
get() { return this.data.map(item => item.value) }
```

## v-for 同时v-if

当`v-for`同时引用`v-if`，如：

```vue
<div v-if="expression" v-for="item in list">...</div>
```

这会产生分歧：判断条件后决定是否跳过整个列表循环 or 循环列表时判断条件控制显示的列表项

最终实际结果取决于`v-if`与`v-for`的执行优先级，事实上vue确定`v-for`优先级高于`v-if`；但依旧会提示不可同时使用的警告信息；

**解决**

- 嵌套

  ```vue
  <ul v-if="expression"><li v-for="item in list"></li></ul>
  <template v-if="expression"><div v-for="item in list"></div></template>
  
  <template v-for="item in list"><li v-if="expression"></li></template>
  ```

- 计算属性

  ```vue
  <div v-for="item in filterList"></div>
  
  <script>
  export default {
  	computed: {
          filterList(){
              if(expression) return [];
              return list.filter(expression);
          }
  	}
  }
  </script>
  ```

- 循环前判断

  ```vue
  <div v-for="item in isEmpty(list) ? [] : list"></div>
  ```

## \$attrs/\$listeners

### $attrs

父组件传递的但未被子组件prop接受的attr集合，可在内部组件上```v-bind="$attrs"```实现prop穿透传递；

```vue
<template>
	<div><input v-model="value" /></div>
</template>
<script>
export default {
    inheritAttrs: false,
    // inherinheritAttrs默认值true，即父组件传递的但未被子组件prop接受的attr会作为标签属性添加至子组件根元素上；
	// false即这一默认行为失效；配合inheritAttrs: false实现更干净的穿透；
    computed: {
        value(){
            return this.$attrs.value;
        }
    }
}
</script>
```

### $listeners

父组件```v-on```监听的事件集合，可在内部组件上```v-on="$listeners"```实现穿透监听；

$listeners实现“监听子组件下某原生元素事件特性”

```vue
<template>
	<div><input v-bind="$attrs" v-on="$listeners" /></div>
</template>
```

## provide/inject

父组件`provide` 

```js
// 值为一个对象
provide: {
	title: '标题'，
	model: { ... }
}

// 值为返回一个对象的函数
provide() {
    return {
        title: this.title,
        claculate: this.claculate,
        getList: this.list
    }
}
```

子组件`inject`

```js
// 注入
inject: ['title', 'model'];
inject: { 
	mainTitle: { from: 'title', default: '' },
	model: { default: () => ({}) },
};

// 注入方法
inject: ['claculate', 'getList'],
computed: {
    list(){ return this.getList() };
}
```

provide/inject的绑定值不会做响应式处理；可传入对象类型的值，借助`property`响应；

 或传入Function类型的值，借助`computed`计算属性实现响应式；

## 事件总线

1. 创建事件总线

   ```js
   Vue.property.$EventBus = new Vue()
   ```

2. 监听事件总线

   ```js
   mounted(){
   	this.$EventBus.$on('add-todo', this.addTodo);
   },
   beforeDestroy() {
     this.$EventBus.$off('add-todo', this.addTodo);
   }
   ```

3. 发射事件总线的事件

   ```js
   this.$EventBus.$emit('delete-todo', options);
   ```

## 动态组件

component(元组件)作为Vue内置组件，通过设置```is```决定哪个具体组件被渲染

```vue
<component
  :is="currentPanelComponent"
  ref="currentPanel"
  v-model="editContent"
  :panelInfo="currentPanel"
  :viewType="0"
></component>

<script>
const panleList = [{id: 'xxx', name: 'xxx', component: panel1}]
export default {
    computed: {
        currentPanel(){
        	return panleList.find((item) => item.id === this.id) || {};
        },
        currentPanelComponent(){
        	return activatedPanel.component;
        }
    }
}
</script>
```

**keep-alive**

配合keep-alive缓存组件状态，避免重复渲染的不必要性能损失

```vue
<keep-alive>
  <component :is="currentTabComponent"></component>
</keep-alive>
```

## 异步组件

组件在被需要时异步加载所需资源并构造，声明一个函数作为异步组件引用

```js
() => import('./my-async-component')
```

```js
// 返回一个带有更多配置的异步组件
const AsyncComponent = () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})
```

## 自定义指令

自定义指令提供了一系列钩子支持对普通DOM元素进行底层操作，包括bind、inserted、update、componentUpdated、unbind；

```js
// 指令
const burySpot = {};
burySpot.install = (Vue) => {
  // bind 和 update简写
  Vue.directive('bury-spot', (el, binding) => {
    el.dataset.buryspot = binding.value;
    el.addEventListener(binding.arg || 'click', burySpotHandle);
  });
};
function burySpotHandle(e) {
  // 提交埋点数据
  request.post({ url: e.currentTarget.dataset.buryspot });
}
export default burySpot;

// 注册
import Vue from 'vue';
import burySpot from './bury-spot';
Vue.use(burySpot);

// 使用
<button type="button" v-bury-spot="https://wwwi.baidu.com"></button>
```

参数： el为DOM元素，binding: { value: 指令值, 支持任何js表达式, oldValue: update/componentUpdated时可用, arg: 指令参数值, modifiers: 修饰符对象, 属性值为布尔值 }

常见场景：埋点、图片默认图/懒加载、权限控制
