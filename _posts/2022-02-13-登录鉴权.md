---
layout:     post
title:      登录鉴权
subtitle:   登录鉴权常见业务处理，包括基本登录流程，记住密码，验证码登录
date:       2022-02-13
author:     page
header-img: img/wallhaven-9mee7x_1900x870.png
catalog: true
tags:
    - 业务需求
---

# 登录鉴权

## 基本登录处理

#### 登录流程

1. 校验并提交登录表单

   ```json
   { username: "xxx", password: "xxx" }
   ```

2. 登录请求成功，返回auth_token

3. 存储autn_token串(localStorage)，跳转至首页

4. 所有请求的header头的PcAuthToken字段值为auth_token值

5. 检测登录状态

   - auth.js：Vue Router添加前置路由(beforeEach)处理，对白名单(whiteList)之外路径跳转时判断登录状态
   - request.js：响应错误判断，返回http状态码403或其它约定登录失效码，检测为登录过期

**注：**auth_token也可以由服务端直接存取至cookie中，前端只需检测响应错误判断；

#### 独立登录处理

将登录/退出登录处理逻辑独立到Vuex中供全局调用

```js
// ./store/user.js
// getters
loginState: () => !!window.localStorage.getItem("auth_token") ? "online" : "offline";
// mutations
LOGIN(state,token){
    // other userInfo handle
    window.localStorage.setItem("auth_token", token);
    this.$message.success("登录成功");
    this.$router.replace("/home");
},
LOGINOUT(state, token){
    // other userInfo handle
    window.localStorage.removeItem("auth_token");
    this.$router.replace("/login");
}
```

## 相关概念

#### session与token区别

session：为了维护用户登录状态，服务端在每个用户登录后存一个唯一sessionId至服务器，每次业务请求时查询sessionId是否存在，存在即用户已登录，可进行下一步处理；

token：服务端不再存储用户登录标识，用户登录成功后生成一个包含用户id、有效期、签名的加密串，每次业务请求时解密token，校验token，校验通过则进行下一步处理；

JWT(Json Web Token)：以json格式传递token的规范，标准token由3部分拼接而成：header(base64转换的签名声明)，payload(base64转换的自定义数据)，signature(对前面2个内容生成加密串的base64编码)

## 记住密码

```js
// 2. 进入登录，查询cookies
created(){
    if(this.$cookies.isKey("userName") && this.$cookies.isKey("password")){
        this.username = this.$cookies.get('username');
        this.password = this.$cookies.get('password');
    }
}
// 1. 登录成功，判断勾选
login(){
	...
	if(this.isRemberPassword){
		// VueCookies 与 js-base64
		this.$cookies.set("username", this.loginForm.username, "3d");
		this.$cookies.set("password", Base64.decode(this.$cookies.get('password')), "3d");
	}else{
		this.$cookies.remove("username");
		this.$cookies.remove("password");
    }
}
```

**注：**纯前端方式记住密码有风险，谨慎使用；

## 权限路由

以通过后端单独接口返回用户权限信息情况下为例

1. router.config.js 声明adminRoutes(所有权限路由)
2. 获取用户role标识，调用addAdminRoutes生成最终权限路由

```js
// ./router/auth.js
export const addAdminRoutes = function() {
  // 用户角色标识
  let userRole = $store.getters["user/userInfo"].role;
  // 渲染侧边栏依赖的路由list
  let rootRoutes = [];
  // 根据角色权限生成路由列表
  adminRoutes.forEach(route => {
    var routesArr = route.children.filter(secondRoute => {
      // 比较角色权限与路由要求权限
      var roles = secondRoute.meta.role;
      if (!roles || roles.includes(userRole)) return true;
      return false;
    });
    if (routesArr.length > 0) { // >0 即具备当前一级路由权限
      route.children = routesArr;
      router.addRoute(route);
      rootRoutes.push(route);
    }
  });
  router.addRoute(errorRoute);
  $store.commit("SET_ADMIN_ROUTES", rootRoutes); // 用于渲染侧边栏
};
// ./router/index.js beforeEach添加处理
if (!$store.getters["user/userInfo"]) {
  $store.dispatch("user/getUserInfo").then(() => addAdminRoutes());
}
```

