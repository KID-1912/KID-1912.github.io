---
layout:     post
title:      Spring框架
subtitle:   一个支持快速开发Java EE应用程序的框架。提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成
date:       2024-06-01
author:     page
header-img: img/Spring.webp
catalog: true
tags:
    - Java
---

# Spring框架

[Spring官网](https://spring.io/projects/spring-framework)

### Spring Framework

[Spring Framework官方文档](https://spring.io/projects/spring-framework)

Spring Framework主要包括几个模块：

- 支持IoC和AOP的容器；
- 支持JDBC和ORM的数据访问模块；
- 支持声明式事务的模块；
- 支持基于Servlet的MVC开发；
- 支持基于Reactive的Web开发；
- 以及集成JMS、JavaMail、JMX、缓存等其他模块。 

## IoC容器

容器，一种为某种特定组件的运行提供必要支持的一个软件环境

Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境

Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程

Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

### IoC原理

如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

因此，核心问题是：

1. 谁负责创建组件？
2. 谁负责根据依赖关系组装组件？
3. 销毁时，如何按依赖顺序正确销毁？

解决这一问题的核心方案就是IoC。

传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制；

在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，

```java
public class BookService {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。

**配置Ioc容器**

IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系，可通过 xml 配置实现

```xml
<beans>
    <bean id="dataSource" class="HikariDataSource" />
    <bean id="bookService" class="BookService">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean id="userService" class="UserService">
        <property name="dataSource" ref="dataSource" />
    </bean>
</beans>
```

IoC容器创建3个JavaBean组件，并把id为`dataSource`的组件通过属性`dataSource`（即调用`setDataSource()`方法）注入到另外两个组件中。

在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean

**依赖注入方式（构造方法）**

```java
public class BookService {
    private DataSource dataSource;

    public BookService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

### 装配Bean

Maven创建工程并引入`spring-context`依赖：

- org.springframework:spring-context:6.0.0

以编写简单 `UserService` 为例

```java
public class UserService {
    private MailService mailService;

    public void setMailService(MailService mailService) {
        this.mailService = mailService;
    }
    ...
}
```

**application.xml**

resources下特定配置文件，Spring的IoC容器应该如何创建并组装Bean：

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="userService" class="com.itranswarp.learnjava.service.UserService">
        <property name="mailService" ref="mailService" />
    </bean>
    <bean id="mailService" class="com.itranswarp.learnjava.service.MailService" />
</beans>
```

- 每个`<bean ...>`都有一个`id`标识，相当于Bean的唯一ID；
- 在`userService`Bean中，通过`<property name="..." ref="..." />`注入了另一个Bean；
- Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。

如果注入的不是Bean，而是`boolean`、`int`、`String`这样的数据类型，则通过`value`注入，例如，创建一个`HikariDataSource`：

```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource">
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="autoCommit" value="true" />
</bean>
```

**创建IoC容器**

`main()` 方法创建一个Spring的IoC容器实例，然后加载配置文件

```java
public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
        UserService userService = context.getBean(UserService.class);
        User user = userService.login("bob@example.com", "password");
        System.out.println(user.getName());
    }
}
```

从`ApplicationContext`中我们可以根据Bean的类型获取Bean的引用：

```java
UserService userService = context.getBean(UserService.class);
```

### Annotation配置

通过 @component 注解方式，不需要XML，让Spring自动扫描Bean并组装它们

```java
// MailService
package com.itranswarp.learnjava.service;
import org.springframework.stereotype.Component;

@Component
public class MailService {
    ...
}

// UserService
package com.itranswarp.learnjava.service;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class UserService {
 @Autowired
 MailService mailService;
 ...
 // 或 set 方法、构造方法中
 public UserService(@Autowired MailService mailService) {
        this.mailService = mailService;
    }
}
```

编写 `AppConfig` 类（AppConfig.java）启动容器

```js
import com.itranswarp.learnjava.service.User;
import com.itranswarp.learnjava.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "com.itranswarp.learnjava.service")
public class AppConfig {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService userService = context.getBean(UserService.class);
        User user = userService.login("bob@example.com", "password");
        System.out.println(user.getName());

    }
}
```

`@Configuration` 标注表示它是一个配置类，因为我们创建 `ApplicationContext` 时，使用的实现类是 `AnnotationConfigApplicationContext`，必须传入一个标注了`@Configuration` 的类名

`@ComponentScan` 标注容器，自动搜索当前类所在的包以及子包，把所有标注为`@Component` 的Bean自动创建出来，并根据 `@Autowired` 进行装配

通常，启动配置 `AppConfig` 位于自定义的顶层包，其他Bean按类别放入子包

### 定制Bean

**Scope**

通过 `@component` 标记的Bean为单例类型（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用`getBean(Class)`获取到的Bean总是同一个实例。

还有一种Bean，我们每次调用 `getBean(Class)`，容器都返回一个新的实例，Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的 `@Scope` 注解：

```java
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // @Scope("prototype")
public class MailSession {
  ...
}
```

**注入List**

可将相同类型的Bean注入 `List` 或数组，常见于一系列接口相同，不同实现类的Bean：

定义一个验证接口

```java
public interface Validator {
    void validate(String email, String password, String name);
}
```

声明3个`Validator`对用户参数进行验证：

```java
@Component
public class EmailValidator implements Validator {
    public void validate(String email, String password, String name) {
        if (!email.matches("^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]{2,10}$")) {
            throw new IllegalArgumentException("invalid email: " + email);
        }
    }
}

@Component
public class PasswordValidator implements Validator {
    public void validate(String email, String password, String name) {
      ...
    }
}

@Component
public class NameValidator implements Validator {
    public void validate(String email, String password, String name) {
      ...
    }
}
```

注入为 validators

```java
@Component
public class Validators {
    @Autowired
    List<Validator> validators;

    public void validate(String email, String password, String name) {
        for (var validator : this.validators) {
            validator.validate(email, password, name);
        }
    }
}
```

`List<Validator> validators`，Spring会自动把所有类型为Validator的Bean装配为一个List注入进来

指定`List`中Bean的顺序，可以加上`@Order`注解：

```java
@Component
@Order(1)
public class EmailValidator implements Validator {
    ...
}
```

**可选注入**

常用于Spring如果没有找到对应类型的Bean，指定默认值

```java
@Component
public class MailService {
    @Autowired(required = false) // 核心代码
    ZoneId zoneId = ZoneId.systemDefault();
    ...
}
```

**第三方Bean**

如果一个Bean不在我们自己的package管理之内，如何创建它

在`@Configuration`类中编写一个Java方法创建并返回它，给方法标记一个`@Bean`注解

```java
@Configuration
@ComponentScan
public class AppConfig {
    // 创建一个Bean:
    @Bean
    ZoneId createZoneId() {
        return ZoneId.of("Z"); // 手动创建返回
    }
}
```

**初始化和销毁**

如果一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。

在容器关闭时，有时候还需要清理资源（关闭连接池等）。

通常会定义一个`init()`方法进行初始化，定义一个`shutdown()`方法进行清理

```java
@Component
public class MailService {
    @Autowired(required = false)
    ZoneId zoneId = ZoneId.systemDefault();

    @PostConstruct // 注入完成时调用
    public void init() {
        System.out.println("Init mail service with zoneId = " + this.zoneId);
    }

    @PreDestroy  // 销毁时
    public void shutdown() {
        System.out.println("Shutdown mail service");
    }
}
```

**使用别名**

默认情况下，对一种类型的Bean，容器只创建一个实例

如果需要对一种类型的Bean创建多个实例。如同时连接多个数据库，就必须创建多个 `DataSource` 实例

如果直接在 `@Configuration` 类中创建了多个同类型的Bean，会报`NoUniqueBeanDefinitionException` 异常，尝试设置别名：

```java
@Configuration
@ComponentScan
public class AppConfig {
    @Primary  // 指定为主要Bean
    @Bean("z")
    ZoneId createZoneOfZ() {
        return ZoneId.of("Z");
    }

    @Bean
    @Qualifier("utc8")
    ZoneId createZoneOfUTC8() {
        return ZoneId.of("UTC+08:00");
    }
}
```

`@Bean("name")`指定别名，也可以用`@Bean`+`@Qualifier("name")`指定别名，注入使用：

```java
@Component
public class MailService {
    @Autowired(required = false)
    @Qualifier("z") // 指定注入名称为"z"的ZoneId
    ZoneId zoneId = ZoneId.systemDefault();
    ...
}
```

`@Primary` 指定的主bean，则默认注入的即主数据源，无需别名指定名称也可

**FactoryBean**

遵循工厂模式，定义一个工创建真正的Bean

```java
@Component
public class ZoneIdFactoryBean implements FactoryBean<ZoneId> {

    String zone = "Z";

    @Override
    public ZoneId getObject() throws Exception {
        return ZoneId.of(zone);
    }

    @Override
    public Class<?> getObjectType() {
        return ZoneId.class;
    }
}
```

### 使用Resource

使用Spring容器时，我们可以把“文件”注入进来，方便程序读取

`org.springframework.core.io.Resource` 支持将一个文件作为 `String`、`int` 那样使用 `@Value` 注入

```java
@Component
public class AppService {
    @Value("classpath:/logo.txt") // 也支持绝对文件路径
    private Resource resource;

    private String logo;

    @PostConstruct
    public void init() throws IOException {
        try (var reader = new BufferedReader(
            new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) {
            this.logo = reader.lines().collect(Collectors.joining("\n"));
        }
    }
}
```

### 注入配置

读取配置文件：常用的配置方法是以 `key=value` 的形式写在 `.properties` 文件中

Spring容器提供了一个更简单的 `@PropertySource` 来自动读取配置文件：

```java
@Configuration
@ComponentScan
@PropertySource("app.properties") // 表示读取classpath的app.properties
public class AppConfig {
    @Value("${app.zone:Z}")
    String zoneId;

    @Bean
    ZoneId createZoneId() {
        return ZoneId.of(zoneId);
    }
}
```

- `"${app.zone}"`表示读取key为`app.zone`的value，如果key不存在，启动将报错；
- `"${app.zone:Z}"`表示读取key为`app.zone`的value，但如果key不存在，就使用默认值`Z`。

或者 `@Bean` 手动创建时，传入到构造方法参数

```java
@Bean
ZoneId createZoneId(@Value("${app.zone:Z}") String zoneId) {
    return ZoneId.of(zoneId);
}
```

另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置：

```java
@Component
public class SmtpConfig {
    @Value("${smtp.host}")
    private String host;

    @Value("${smtp.port:25}")
    private int port;

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }
}
```

### 条件装配

Spring为应用程序准备了Profile这一概念，用来表示不同的环境。如分别定义开发、测试和生产这3个环境：

- native
- test
- production

**@Profile**

根据注解 `@Profile` 来决定是否创建。例如：

```java
@Configuration
@ComponentScan
public class AppConfig {
    @Bean
    @Profile("!test")
    ZoneId createZoneId() {
        return ZoneId.systemDefault();
    }

    @Bean
    @Profile("test")
    ZoneId createZoneIdForTest() {
        return ZoneId.of("America/New_York");
    }
}
```

在运行程序时，加上JVM参数 `-Dspring.profiles.active=test` 就可以指定以 `test` 环境启动；Spring允许指定多个Profile：`-Dspring.profiles.active=test,master`

可以表示 `test` 环境，并使用 `master` 分支代码

要指定满足多个Profile条件，可以这样写：

```java
@Bean
@Profile({ "test", "master" }) // 满足test或master
ZoneId createZoneId() {
    ...
}
```

**@Conditional**

支持自定义条件逻辑，如：

```java
@Component
@Conditional(OnSmtpEnvCondition.class) // 条件实现类
public class SmtpMailService implements MailService {
    ...
}
```

```java
public class OnSmtpEnvCondition implements Condition {
    // 注意此处是对 Condition 实现
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return "true".equalsIgnoreCase(System.getenv("smtp"));
    }
}
```

## AOP

即面向切面编程（Aspect Oriented Programming）

思考业务模型，如安全检查、日志、事务等代码，它们会重复出现在每个业务方法中

加入AOP的视角来编写上述业务，可以依次实现：

1. 核心逻辑，即：BookService
2. 切面逻辑，即：权限检查的Aspect、日志的Aspect、事务的Aspect

**原理**

如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了`BookService`的引用，当调用`bookService.createBook()`时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理；

最简单的方式是运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。

Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过[CGLIB](https://github.com/cglib/cglib)或者[Javassist](https://www.javassist.org/)这些第三方库实现。

AOP本质是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。

AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。

另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。

### 装配AOP

通过Maven引入Spring对AOP的支持：

- org.springframework:spring-aspects:6.0.0

上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便，因为它的定义比较简单：

```java
@Aspect
@Component // 作为一个bean
public class LoggingAspect {
    // 在执行UserService的每个方法前执行:
    @Before("execution(public * com.itranswarp.learnjava.service.UserService.*(..))")
    public void doAccessCheck() {
        System.err.println("[Before] do access check...");
    }

    // 在执行MailService的每个方法前后执行:
    @Around("execution(public * com.itranswarp.learnjava.service.MailService.*(..))")
    public Object doLogging(ProceedingJoinPoint pjp) throws Throwable {
        System.err.println("[Around] start " + pjp.getSignature());
        Object retVal = pjp.proceed(); // 连接点执行目标方法
        System.err.println("[Around] done " + pjp.getSignature());
        return retVal;
    }
}
```

定义 `@Before`，后面的字符串是告诉AspectJ应该在何处执行该方法，这里写的意思是：执行`UserService`的每个`public`方法前执行`doAccessCheck()`代码。

定义 `@Around`，它和`@Before`不同，`@Around`可以决定是否执行目标方法，因此，我们在`doLogging()`内部先打印日志，再调用方法，最后打印日志后返回结果。

`@Configuration` 类加上一个 `@EnableAspectJAutoProxy` 注解：

```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class AppConfig {
    ...
}
```

IoC容器看到这个注解，就会自动查找带有`@Aspect`的Bean，然后根据每个方法的`@Before`、`@Around`等注解把AOP注入到特定的Bean中。

**拦截器类型**

- @Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；

- @After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；

- @AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；

- @AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；

- @Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。

### 注解装配

通过复杂的 `execution(* xxx.Xyz.*(..))` AOP规则装配到指定Bean的指定方法前后，常导致后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配

通过注解装配AOP，如

```java
@Target(METHOD)
@Retention(RUNTIME)
public @interface MetricTime {
    String value();
}
```
