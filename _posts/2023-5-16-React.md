---
layout:     post
title:      React
subtitle:   用于构建 Web 和原生交互界面的库
date:       2023-5-16
author:     page
header-img: img/react.jpg
catalog: true
tags:
    - React
---

# React

中文文档：[https://react.docschina.org/](https://react.docschina.org/) 官方文档：[https://react.dev/](https://react.dev/)

## 安装

```shell
npm install react react-dom
```

`react`：包含 React 的核心功能，包括创建组件、管理组件的生命周期和处理状态等。它是你编写 React 组件所需的基础库。

`react-dom`：提供了将 React 组件渲染到 DOM（Document Object Model）中的特定方法。

## 框架构建

**Next.js**：`npx create-next-app@latest`

**create-react-app**：`npx create-react-app my-app`

**vite**：`npm create vite@latest my-app -- --template react`

## 基础

### porps

```jsx
export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}
```

**条件渲染**

使用 JavaScript 的 `if` 语句、`&&` 和 `? :` 运算符来选择性地渲染 JSX；

**渲染列表**

`filter()` 筛选需要渲染的组件和使用 `map()` 把数组转换成组件数组。

### 事件

```jsx
<button onClick={handleClick}>Button</button>
```

### 更新state

`setMessage(e.target.value)`

`setState((index) => index + 100)`

**更新对象**

```jsx
setPosition({ x: e.clientX, y: e.clientY });
const nextArtists = [...artists.slice(0, insertAt)];
setArtists(nextArtists);
```

```jsx
import { useImmer } from 'use-immer';
const [person, updatePerson] = useImmer({})
updatePerson(draft => {
  draft.artwork.city = e.target.value;
});
updateMyList(draft => {
  const artwork = draft.find(a => a.id === id);
  artwork.seen = nextSeen;
});
```

**state的保留与重置**

相同位置的相同组件会使得 state 被保留下来（可使用key以及多个组件实现重置）

相同位置的不同组件会使 state 重置

react中key更新，也会触发重新渲染

### Reducer

```js
function tasksReducer(tasks, action) {
  if (action.type === 'added') {
    ......
    return [];
  }
}
```

```js
import { useReducer } from 'react';
import { useImmerReducer } from 'use-immer';
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
const [tasks, dispatch] = useImmerReducer(tasksReducer, initialTasks);
```

### Context

创建 context

```jsx
import { createContext } from 'react';

export const LevelContext = createContext(1);
```

使用 context

```jsx
import { LevelContext } from './LevelContext.js';
export default function Heading({ children }) {
  const level = useContext(LevelContext); // 访问上层最近
  // ...
}
```

提供 context

```jsx
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';

export default function Section({ children }) {
  const level = useContext(LevelContext); // 访问上层最近
  return (
    <section className="section">
      <LevelContext.Provider value={level + 1}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```

### reducer + context

创建 context

```jsx
import { createContext } from 'react';

export const TasksContext = createContext(null);
export const TasksDispatchContext = createContext(null);
```

state 和 dispatch 函数 放入 context

```jsx
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
  // ...
  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>
        ...
      </TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}
```

接收使用

```jsx
export default function TaskList() {
  const tasks = useContext(TasksContext);
  // ...
```

```jsx
export default function AddTask() {
  const [text, setText] = useState('');
  const dispatch = useContext(TasksDispatchContext);
  // ...
  return (
    // ...
    <button onClick={() => {
      setText('');
      dispatch({
        type: 'added',
        id: nextId++,
        text: text,
      });
    }}>Add</button>
    // ...
```

迁移逻辑

```jsx
import { createContext, useContext, useReducer } from 'react';

const TasksContext = createContext(null);

const TasksDispatchContext = createContext(null);

export function TasksProvider({ children }) {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>
        {children}
      </TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}

export function useTasks() {
  return useContext(TasksContext);
}

export function useTasksDispatch() {
  return useContext(TasksDispatchContext);
}
```

### ref

使用 ref使组件记住某些信息（常规变量是记不住的），且让这些信息不会触发新的渲染

**存储变量值**

```jsx
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('你点击了 ' + ref.current + ' 次！');
  }
```

**引用DOM**

```jsx
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        聚焦输入框
      </button>
    </>
  );
}
```

**访问组件的DOM**

```jsx
//  这让从上面接收的 inputRef 作为第二个参数 ref 传入组件
const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
}); 

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        聚焦输入框
      </button>
    </>
  );
}
```

### effect

Effects 会在渲染后运行一些代码，实现副作用；

**渲染逻辑代码** 位于组件的顶层，最终返回你想在屏幕上看到的 JSX。渲染的代码必须是纯粹的——就像数学公式一样，它只应该“计算”结果，而不做其他任何事情。

**事件处理程序**是嵌套在组件内部的函数，而不仅仅是计算函数。事件处理程序可能会更新输入字段、提交 HTTP POST 请求以购买产品，或者将用户导航到另一个屏幕。事件处理程序包含由特定用户操作（例如按钮点击或键入）引起的“副作用”；

**Effect 允许你指定由渲染本身，而不是特定事件引起的副作用**

```jsx
import { useEffect } from 'react';
function MyComponent() {
  useEffect(() => {
    // 每次渲染后都会执行此处的代码
  });
  return <div />;
}
```

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  // 渲染后
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

```

**指定Effect依赖**

```jsx
useEffect(() => {
  // 这里的代码会在每次渲染后执行
});

useEffect(() => {
  // 这里的代码只会在组件挂载后执行
}, []);

useEffect(() => {
  //这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行
}, [a, b]);
```

**注**：Effect 读取的每一个响应式值都必须在其依赖项中声明

**添加清理（cleanup）函数**

重复挂载组件，可以确保在 React 中离开和返回页面时不会导致代码运行出现问题

为了解决这个问题，可以在 Effect 中返回一个 **清理（cleanup）** 函数。

```jsx
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => {
      connection.disconnect();    // 指定卸载组件时处理
    };
  }, []);
```

**处理开发环境中 Effect 执行两次**

控制非 React 组件

```jsx
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);]);
```

订阅事件

```jsx
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

触发动画

```jsx
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // 触发动画
  return () => {
    node.style.opacity = 0; // 重置为初始值
  };
}, []);
```

获取数据

Effect 将会获取数据，清理函数应该要么 中止该数据获取操作，要么忽略其结果：

```jsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

### memo

记忆缓存

```jsx
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ✅ 除非 todos 或 filter 发生变化，否则不会重新执行 getFilteredTodos()
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}]);
```

### callback

### 自定义Hook

```jsx
import { useState, useEffect } from 'react';

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}

```

**传递响应值**

```jsx
export function useChatRoom({ serverUrl, roomId }) {
  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      showNotification('New message: ' + msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
}
```

```jsx
import { useEffect, useEffectEvent } from 'react';
// ...

// 传递值包含事件处理
export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
  // 防止每次组件重新渲染时聊天室就会重新连接
  const onMessage = useEffectEvent(onReceiveMessage); // useEffectEvent

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    connection.on('message', (msg) => {
      onMessage(msg);
    });
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ✅ 声明所有依赖
}
```
