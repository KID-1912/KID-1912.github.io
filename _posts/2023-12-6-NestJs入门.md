---
layout:     post
title:      NestJs入门
subtitle:   构建高效、可扩展的 Node.js 服务器端应用的框架。采用模块化架构允许使用任何其他库，为您提供真正的灵活性。
date:       2023-12-6
author:     page
header-img: img/NextJs.png
catalog: true
tags:
    - NodeJs
---

# NestJs

## 开始

### 创建项目

**Nest命令行创建**

```shell
npm i -g @nestjs/cli
nest new project-name
```

**手动创建**

```shell
npm i --save @nestjs/core @nestjs/common rxjs reflect-metadata
```

### 核心文件

`app.module.t` 应用的根模块

`app.controller.ts` 具有单一路由的基本控制器

`app.service.ts` 具有单一方法的基本服务

`app.controller.spec.ts` 控制器的单元测试文件

`main.ts` 使用核心函数 `NestFactory` 创建 Nest 应用实例的应用入口文件

### 启动

```shell
npm run start:dev
```

## Controller

### 路由

控制器负责处理传入的 **requests** 并将 **responses** 返回给客户端，采用 **routing** 机制控制哪个控制器接收哪些请求

```ts
import { Controller, Get, Post } from '@nestjs/common';
import { AppService } from './app.service';
// 路由路径前缀，对路由分组
@Controller('article')
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('one') // 请求方法装饰器为 HTTP 请求的特定端点创建处理程序
  // /article/one
  getArticle(): string {
    return this.appService.getArticle();
  }

  @Post()
  editArticle(): string {
    return this.appService.editArticle();
  }
}
```

**请求方法**

所有标准的HTTP 方法装饰器：`@Get()`、`@Post()`、`@Put()`、`@Delete()`、`@Patch()`、`@Options()` 和 `@Head()`；

此外定义了一个 `@All()` 来处理所有HTTP 方法

**路由通配符**

路由路径支持正则的通配符匹配，如 `@Get('article*')`

**子域路由**

除了匹配路径的路由，支持host选项指定匹配主机的路由

```ts
@Controller({ host: 'xxx.example.com' })
export class AppController() {
  @Get()
  getData(): string {  // 支持 @HostParam() 获取动态主机参数
    // 子域路由处理
  }
}
```

### 操作响应

默认nest根据请求处理返回数据的类型选择是否自动序列化，且 **状态码** 默认情况下始终为 200，可通过 `@HttpCode()` 装饰器自定义 ;

对于动态状态码，可通过使用库的响应对象上原生响应处理方法，以 `express` 为例：

```ts
@Get()
getArticle(@Res() response): void {
  const data = this.appService.getArticle();
  response.status(400).send(data)
}
```

### 请求对象

通过 `@Req()` 装饰器访问客户端 **request** 的详细信息

```ts
import { Controller, Get, Post, Req, Res } from '@nestjs/common';
import { AppService } from './app.service';
import { Request } from 'express';

@Controller('article')
export class AppController {
  constructor(private readonly appService: AppService) {}
  @Get('one')
  getArticle(@Req() request: Request, @Res() response): void {
    const data = this.appService.getArticle();
    console.log(request)
    response.status(400).send(data)
  }
}
```

### 状态码

如前面所述，默认响应状态码 200（post为201），可通过装饰器 `@HttpCode(code)` 修改行为

```ts
@Post('list')
@HttpCode(200)
getList(){
  ...
}
```

### 响应头

使用装饰器 `@Header()` 或库的响应对象 `res.header()` 自定义响应头

```ts
@Post('login')
@Header('Cookie', 'xxxx')
login(){
  ...
}
```

### 重定向

使用装饰器 `@Redirect` 或库的响应对象 `res.redirect()` 响应重定向

```ts
@Post('login')
@Redirect('https://nest.nodejs.cn', 301)
```

### 路由参数

通过带参数的路由（动态路径）传参时，通过 `@Param` 装饰器访问

```ts
@Get('info/:id')
getInfo(@Param('id') id: string): string {
  return `info: id is ${id}`
}
```

### 异步处理

采用异步处理让Nest解析延迟值

```ts
@Get()
async fingAll(): Promise<any[]> {
  return [];
}
```

### 请求负载

通过 `@Body()` 装饰器接收POST路由参数，在此之前需要先使用class类或Ts接口声明DTO

```ts
// 推荐使用class类
const class CreateDTO {
  name: string;
  age: number;
}
```

```ts
@Post('create)
async create(@Body() createDTO: CreateDTO): string {
  ......
}
```

### 特定库的响应对象

允许通过库的响应对象暴露API进行完全控制

```ts
import { Post, Res, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Post()
create(@Res() res: Response) {
  res.status(HttpStatus.CREATED).json([]);
}
```

这会失去Nest标准响应功能，可以设置响应头 `passthrough` 实现兼容

```ts
@Get()
findAll(@Res({ passthrough: true }) res: Response) {
  res.status(HttpStatus.OK);
  ......
  return [];
}
```

### 使用控制器类

声明的 `Controller`  类在  `@Module()` 装饰器的 `controllers` 将元数据附加到模块类

```ts
// 根模块类 app.module.ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController], // 模块所需控制器
})
export class AppModule {}
```

## Provider

NestJs中专于向其它对象提供功能并通过 `injected` 建立依赖关系的类，按功能可划分为服务、存储库、工厂、助手

### 定义提供者 `@Injectable`

```ts
import { Injectable } from '@nestjs/common';
import { Article } from "./interfaces/article.interface"

@Injectable()
export class ArticleService {
  private readonly articles: Array<Article> = [];

  createArticle(article: Article): Article {
    this.articles.push(article)
    return article;
  }

  getArticles(): Array<Article> {
    return this.articles;
  }
}
```

### 定义类型

```ts
export interface Article {
  name: string,
  author: string,
  pageTotal: number
}
```

### 定义DTO

```ts
export class CreateArticleDTO {
  name: string;
  author: string;
  pageTotal: number
}
```

### Controll中使用

```ts
import { Controller, Get, Post, Body } from '@nestjs/common';
import { CreateArticleDTO } from "./dto/create-article.dto";
import {Article} from "./interfaces/article.interface"
import { ArticleService } from './article.service';

@Controller('article')
export class ArticleController {
  // 类私有的实例属性
  constructor(private readonly articleService: ArticleService) {
  
  }

  @Get('all')
  async getArticles(): Promise<Array<Article>> {
    return await this.articleService.getArticles();
  }

  @Post('create')
  async createArticle(@Body() createArticleDTO: CreateArticleDTO): Promise<Article> {
    return await this.articleService.createArticle(createArticleDTO)
  }
}
```
